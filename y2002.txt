

const url = 'https://raw.githubusercontent.com/zbz31/zbz31.github.io/refs/heads/main/ygjap5.txt';

async function fetchCards() {
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error('Network response was not ok');
    const data = await response.text();
    const cards = JSON.parse(data); // Parse the fetched data
    cards.sort((a, b) => parseInt(b.rank) - parseInt(a.rank)); // Sort the cards by rank
    //cards.sort((a, b) => parseInt(a.name) - parseInt(b.name)); // Sort the cards by name
    return cards;
  } catch (error) {
    console.error('Fetch error:', error);
    return [];
  }
}



document.addEventListener("DOMContentLoaded", async () => {


    var allcards = await fetchCards(); // Wait for cards to be fetched
    searchc = []
    orderclassic = ""
    let currentFlagGrid = []

    initLocalStorage();

    let newCell;
    let newCell2

    indice2();

    function padAtkVal(value) {
      let str = String(value); // Convert to string
      // Pad with leading zeros to ensure a consistent length for comparison
      str = str.padStart(15, '0'); // Adjust 15 as needed
      return str;
    }

    function initLocalStorage() {
      const storedcurrentFlagPuzzle = window.localStorage.getItem('currentFlagPuzzle');

      const storedcurrentFlagGrid = window.localStorage.getItem('current4FlagGrid');
      if (!storedcurrentFlagGrid) {
        window.localStorage.setItem('current4FlagGrid', currentFlagGrid);
      } else {
        currentFlagGrid = JSON.parse(storedcurrentFlagGrid);
      }


      if (!storedcurrentFlagGrid) {
        window.localStorage.setItem('current4FlagGrid', currentFlagGrid);
      } else {
        currentFlagGrid = JSON.parse(storedcurrentFlagGrid);
      }
      const storedFlagArchive = window.localStorage.getItem('currentFlagArchive');
      if (storedFlagArchive === "no") {


      }
      if (!storedFlagArchive) {
        window.localStorage.setItem('currentFlagArchive', "no");
      }

    }

    function showModalExtra(name, flags) {


      const modal = document.getElementById('modal2');
      const headline = document.getElementById('modal-headline2');
      const btnmodal = document.getElementById('close-modal2');

      // Create a function to clear the modal content
      function clearModal() {
        const linesContainer = modal.querySelector('div');
        if (linesContainer) {
          modal.removeChild(linesContainer);
        }
      }

      function closeModalans() {
        clearModal(); // Clear the modal content

        modal.style.display = "none";

      }

      btnmodal.addEventListener("click", closeModalans);
      btnmodal.style.marginTop = '-10px'; // Adjust the value as needed to raise the button

      headline.textContent = name;
      headline.style.fontFamily = "'Strait', sans-serif";
      headline.style.fontSize = '16.5px';
      headline.style.marginTop = '5px'; // Adjust the value as needed to lower the headline

      modal.style.opacity = '0';
      modal.style.display = 'block';
      modal.offsetHeight; // Trigger a reflow to ensure the transition works
      modal.style.transition = 'opacity 0.65s';
      modal.style.opacity = '1';

      // Set adaptive width and height
      modal.style.width = '70vw'; // 70% of the viewport width
      modal.style.height = '70vh'; // 70% of the viewport height

      // Position the modal closer to the top
      modal.style.position = 'fixed';
      modal.style.top = '7%'; // Adjust this value to move the modal closer to the top
      modal.style.left = '50%';
      modal.style.transform = 'translate(-50%, 0)'; // Vertical position is set by 'top'

     const characters = [
  
          'Name ↓',
          'Name ↑',

          '⚔️ ATK ↓', 
          '⚔️ ATK ↑',

          '🛡️ DEF ↓',
          '🛡️ DEF ↑',

          '★ Level/Rank ↓',
          '★ Level/Rank ↑',
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        characters.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }

          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
          line.textContent = color;

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect

      


            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            line.style.backgroundColor = 'lightgreen'; // Change to the second color
            line.style.transform = 'scale(0.98)';
            setTimeout(() => {
              line.style.transform = 'scale(1)';
              line.style.backgroundColor = 'white'; // Revert back to white
            }, 300); // Change the number (2000) to the number of milliseconds you want


         



              //here is where it starts
              const ul = document.createElement('ul');
              ul.style.listStyleType = 'none';
              ul.style.padding = '0';
              ul.style.margin = '0';




              const li2 = document.createElement('li');

              // Set the text content for the list item
              li2.textContent = flags.length + " results";

              // Check for the number of results
              if (flags.length > 249) {
                li2.textContent = "250+ results";
              }

              // Style the list item
              li2.style.display = 'flex';
              li2.style.alignItems = 'center';
              li2.style.marginBottom = '10px'; // Optional
              li2.style.fontWeight = 'bold'; // Make the text bold



              const btnback7 = document.createElement('button');
              btnback7.textContent = "Ordered by " + line.textContent; // Set button text
              btnback7.style.marginLeft = 'auto'; // Push the button to the right
              // Optionally, add styles to the button
              btnback7.style.padding = '4px 8px';
              btnback7.style.cursor = 'pointer';

              btnback7.style.backgroundColor = 'lightgray'; // Green background
              btnback7.style.color = 'black'; // White text
              btnback7.style.border = 'none'; // No border

              btnback7.style.fontSize = '10px'; // Font size
              btnback7.style.fontFamily = "'Strait', sans-serif";
              btnback7.style.cursor = 'pointer'; // Pointer cursor
              btnback7.style.borderRadius = '4px'; // Rounded corners


              // Append the button to li2
              li2.appendChild(btnback7);
              btnback7.addEventListener('click', () => {
                showModalExtra("Order By", flags);
      
              });

              // Append li2 to the unordered list
              ul.appendChild(li2);


              

              flags.sort((a, b) => {



                

                if (line.textContent === "Name ↓") {

                  return a.couname.localeCompare(b.couname);
                }

                if (line.textContent === "Name ↑") {

                  return b.couname.localeCompare(a.couname);
                }
                if (line.textContent === "⚔️ ATK ↑") {

                  return (("aaaaa" + padAtkVal(a.atkval)).localeCompare("aaaaa" + padAtkVal(b.atkval)));
                }
                if (line.textContent === "⚔️ ATK ↓") {
                  return (("aaaaa" + padAtkVal(b.atkval)).localeCompare("aaaaa" + padAtkVal(a.atkval)));

             
                }
                if (line.textContent === "🛡️ DEF ↑") {

                  return (("aaaaa" + padAtkVal(a.defval)).localeCompare("aaaaa" + padAtkVal(b.defval)));
                }
                if (line.textContent === "🛡️ DEF ↓") {

                  return (("aaaaa" + padAtkVal(b.defval)).localeCompare("aaaaa" + padAtkVal(a.defval)));
                }
                if (line.textContent === "★ Level/Rank ↓") {

                  return (("aaaaa" + padAtkVal(a.lvel)).localeCompare("aaaaa" + padAtkVal(b.lvel)));
                }
                if (line.textContent === "★ Level/Rank ↑") {

                  return (("aaaaa" + padAtkVal(b.lvel)).localeCompare("aaaaa" + padAtkVal(a.lvel)));
                }


                return 0;
              }).slice(0, 250).forEach(flag => {
                const li = document.createElement('li');
                li.style.display = 'flex';
                li.style.alignItems = 'center';
                li.style.marginBottom = '10px'; // Optional: add some space between list items

                // Create an anchor element for the hyperlink
                const a = document.createElement('a');
                a.href = flag.cardlink;  // Set the URL from flags.cardlink
                a.style.textDecoration = 'none';  // Remove underline from text (optional)
                a.style.color = 'inherit';  // Keep the original text color
                a.style.display = 'flex';  // Make anchor a flex container
                a.style.alignItems = 'center';  // Center items vertically in the anchor

                // Create an image element for the flag
                const img = document.createElement('img');
                img.src = flag.cardpic;
                img.alt = `${flag.couname} Flag`;
                img.style.width = '20px'; // Adjust the width as needed
                img.style.height = 'auto'; // Adjust the height as needed
                img.style.marginRight = '10px'; // Space between the image and text
                img.style.borderRadius = '10%'; // Rounded corners
                img.style.border = '1px solid #000'; // Add a border (adjust color and thickness as needed)

                // Set image to be clickable and trigger modal
                img.style.cursor = "pointer";
                img.addEventListener('click', function (e) {

                  e.preventDefault();  // Prevent the link from being followed when clicking the image
                  showmodalCard(flag);
                });

                // Append the image to the anchor
                a.appendChild(img);

                // Set the text content of the anchor
                const textNode = document.createTextNode(flag.couname);
                const atkSpan = document.createElement('span');
                atkSpan.style.marginLeft = 'auto'; // Push ATK text to the right
                atkSpan.textContent = "(☆" + `${flag.lvel}` + ") " + `${flag.atkval}` + " - " + `${flag.defval}`;
                atkSpan.style.fontSize = '0.7em'; // Set smaller font size
                a.appendChild(textNode);
                li.appendChild(a);


                if (flag.atkval !== undefined && flag.defval !== undefined) {
                  li.appendChild(atkSpan); // Append the ATK text after the anchor
                  // Append the list item to the unordered list
                }
             

                // Append the list item to the unordered list
                if (!(line.textContent.includes("ATK") && flag.atkval === undefined) && !(line.textContent.includes("DEF") && flag.defval === undefined) && !(line.textContent.includes("Level/Rank") && flag.lvel === undefined)) {
                  ul.appendChild(li);
                }
              });

              newCell2.textContent = "";
              newCell2.appendChild(ul);


            flags.sort((a, b) => {

              if (line.textContent === "Name ↓") {

                return a.couname.localeCompare(b.couname);
              }

              if (line.textContent === "Name ↑") {

                return b.couname.localeCompare(a.couname);
              }
              if (line.textContent === "⚔️ ATK ↑") {

                return (("aaaaa" + padAtkVal(a.atkval)).localeCompare("aaaaa" + padAtkVal(b.atkval)));
              }
              if (line.textContent === "⚔️ ATK ↓") {
                return (("aaaaa" + padAtkVal(b.atkval)).localeCompare("aaaaa" + padAtkVal(a.atkval)));


              }
              if (line.textContent === "🛡️ DEF ↑") {

                return (("aaaaa" + padAtkVal(a.defval)).localeCompare("aaaaa" + padAtkVal(b.defval)));
              }
              if (line.textContent === "🛡️ DEF ↓") {

                return (("aaaaa" + padAtkVal(b.defval)).localeCompare("aaaaa" + padAtkVal(a.defval)));
              }

              if (line.textContent === "★ Level/Rank ↓") {

                return (("aaaaa" + padAtkVal(a.lvel)).localeCompare("aaaaa" + padAtkVal(b.lvel)));
              }
              if (line.textContent === "★ Level/Rank ↑") {

                return (("aaaaa" + padAtkVal(b.lvel)).localeCompare("aaaaa" + padAtkVal(a.lvel)));
              }


              return 0;
            }).slice(0, 250).forEach(flag => {
              const li = document.createElement('li');
              li.style.display = 'flex';
              li.style.alignItems = 'center';
              li.style.marginBottom = '10px'; // Optional: add some space between list items

              // Create an anchor element for the hyperlink
              const a = document.createElement('a');
              a.href = flag.cardlink;  // Set the URL from flags.cardlink
              a.style.textDecoration = 'none';  // Remove underline from text (optional)
              a.style.color = 'inherit';  // Keep the original text color
              a.style.display = 'flex';  // Make anchor a flex container
              a.style.alignItems = 'center';  // Center items vertically in the anchor

              // Create an image element for the flag
              const img = document.createElement('img');
              img.src = flag.cardpic;
              img.alt = `${flag.couname} Flag`;
              img.style.width = '20px'; // Adjust the width as needed
              img.style.height = 'auto'; // Adjust the height as needed
              img.style.marginRight = '10px'; // Space between the image and text
              img.style.borderRadius = '10%'; // Rounded corners
              img.style.border = '1px solid #000'; // Add a border (adjust color and thickness as needed)

              // Set image to be clickable and trigger modal
              img.style.cursor = "pointer";
              img.addEventListener('click', function (e) {

                e.preventDefault();  // Prevent the link from being followed when clicking the image
                showmodalCard(flag);
              });

              // Append the image to the anchor
              a.appendChild(img);

              // Set the text content of the anchor
              a.appendChild(document.createTextNode(flag.couname));



              // Append the anchor to the list item
              li.appendChild(a);

              // Append the list item to the unordered list
              if ((line.textContent.includes("ATK") && flag.atkval === undefined) || (line.textContent.includes("DEF") && flag.defval === undefined) || (line.textContent.includes("Level/Rank") && flag.defval === undefined)) {
                ul.appendChild(li);
              }
            });

            newCell2.appendChild(ul);

            
            closeModalans(); 
          });
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      








      // Close modal when clicking outside the textbox
      modal.addEventListener('click', function (event) {
        if (event.target === modal) {
          closeModalans(); // Use closeModalans to clear the modal content
        }
      });
    }











    function showModal(name) {


      const modal = document.getElementById('modal2');
      const headline = document.getElementById('modal-headline2');
      const btnmodal = document.getElementById('close-modal2');

      // Create a function to clear the modal content
      function clearModal() {
        const linesContainer = modal.querySelector('div');
        if (linesContainer) {
          modal.removeChild(linesContainer);
        }
      }

      function closeModalans() {
        clearModal(); // Clear the modal content

        modal.style.display = "none";

      }

      btnmodal.addEventListener("click", closeModalans);
      btnmodal.style.marginTop = '-10px'; // Adjust the value as needed to raise the button

      headline.textContent = name;
      headline.style.fontFamily = "'Strait', sans-serif";
      headline.style.fontSize = '16.5px';
      headline.style.marginTop = '5px'; // Adjust the value as needed to lower the headline

      modal.style.opacity = '0';
      modal.style.display = 'block';
      modal.offsetHeight; // Trigger a reflow to ensure the transition works
      modal.style.transition = 'opacity 0.65s';
      modal.style.opacity = '1';

      // Set adaptive width and height
      modal.style.width = '70vw'; // 70% of the viewport width
      modal.style.height = '70vh'; // 70% of the viewport height

      // Position the modal closer to the top
      modal.style.position = 'fixed';
      modal.style.top = '7%'; // Adjust this value to move the modal closer to the top
      modal.style.left = '50%';
      modal.style.transform = 'translate(-50%, 0)'; // Vertical position is set by 'top'

      // Create a container for the colored lines



      if (name.includes("Played By")) {
        const colors = [
          ' ',
          'Duel Monsters',
          '🟦 Yugi Muto',
          '🟩 <strong>Joey Wheeler</strong> / Katsuya Jonouchi',
          '🟩 Seto Kaiba',

          '🟫 Mai Valentine',
          '🟫 Mako Tsunami',
          '🟫 Rex Raptor / Dinosaur Ryuzaki',

          '🟫 Weevil Underwood / Insector Haga',
          '🟥 Maximillion Pegasus / Pegasus J. Crawford',
          '🟥 Marik Ishtar / Yami Marik',
          '🟥 Ryo Bakura',

          '  ',
          'GX',
          '🟦 Jaden Yuki',
          '🟩 Chazz Princeton',
          '🟩 Zane Truesdale',
          '🟫 Alexis Rhodes',
          '🟫 Bastion Misawa',
          '🟥 Yubel',
          '🟥 Nightshroud',
          '🟥 Sartorius',
          '  ',
          '5Ds',
          '🟦 Yusei Fudo',
          '🟩 Jack Atlas',
          '🟩 Crow Hogan',
          '🟫 Akiza Izinski',
          '🟫 Kalin Kessler',
          '  ',

          'Zexal',
          '🟦 Yuma Tsukumo',
          '🟩 Jack Atlas',
          '🟩 Crow Hogan',
          '🟫 Akiza Izinski',
          '🟫 Kalin Kessler',
          '🟥 Ryo Bakura',
          '  ',

          'VRAINS',
          '🟦 Yusaku - Playmaker',
          '🟩 Jack Atlas',
          '🟩 Crow Hogan',
          '🟥 George Gore',

        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        colors.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'space-between'; // Space between text and buttons
          line.style.height = '12px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          if (color !== ' ' && color !== 'Main Color' && color !== '  ' && color !== 'GX' && color !== '5Ds' && color !== 'Zexal' && color !== 'Arc-V' && color !== 'VRAINS' && color !== 'Duel Monsters') {
            line.style.height = '30px';
            line.style.backgroundColor =
              searchc.includes(`(No): 🚫 ${color}`)
                ? 'lightcoral'
                : searchc.includes(color)
                  ? 'lightgreen'
                  : 'white';
          }
          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance

          // Create text node for the color
          const colorText = document.createTextNode(color);
          const textContainer = document.createElement('div');
          textContainer.style.flexGrow = '1'; // Allow text to take available space
          if (color !== '...') {
            textContainer.appendChild(colorText); // Append text to text container
          }
          else {
            textContainer.appendChild(document.createTextNode(''))
          }
          line.appendChild(textContainer);
          // Create YES button
          if (color === ' ') {

            const yesButton = document.createElement('button');
            yesButton.textContent = 'YES';
            yesButton.style.marginLeft = '5px'; // Space between text and button

            yesButton.style.backgroundColor = 'lightgreen';
            yesButton.style.color = 'black';
            yesButton.style.border = 'none';
            yesButton.style.borderRadius = '5px';
            yesButton.style.padding = '3.5px 5px';
            yesButton.style.fontFamily = "'Strait', sans-serif";
            yesButton.style.fontSize = "10px";
            // Create NO button
            const noButton = document.createElement('button');
            noButton.textContent = 'NO';
            noButton.style.marginLeft = '6px'; // Increased space between YES and NO

            noButton.style.backgroundColor = 'lightcoral';
            noButton.style.color = 'black';
            noButton.style.border = 'none';
            noButton.style.borderRadius = '5px';
            noButton.style.padding = '3.5px 5px';
            noButton.style.fontFamily = "'Strait', sans-serif";
            noButton.style.fontSize = "10px";

            // Add additional right margin to the last button
            noButton.style.marginRight = '1px'; // Space from the right margin
            line.appendChild(textContainer);
            line.appendChild(yesButton);
            line.appendChild(noButton);
          } else if (color !== ' ' && color !== 'Main Color' && color !== '...' && color !== '  ' && color !== 'GX' && color !== '5Ds' && color !== 'Zexal' && color !== 'VRAINS' && color !== 'Arc-V' && color !== 'Duel Monsters') {
            const yesButton = document.createElement('button');

            yesButton.style.cssText = `
    margin: 0 10px 0 5px; 
    cursor: pointer; 
    background-color: transparent; 
    color: black; 
    border: 2px solid lightgreen; 
    border-radius: 50%; 
    width: 16px; 
    height: 16px; 
    padding: 0; 
    font-family: 'Strait', sans-serif; 
     float: right; 
        float: right; 
           
    margin-right: 12px; 
   
`;


            if (color.includes("Optional")) {
              yesButton.style.cssText = `
    margin: 0 22px 0 5px; 
    cursor: pointer; 
    background-color: transparent; 
    color: black; 
    border: 2px solid lightgreen; 
    border-radius: 50%; 
    width: 16px; 
    height: 16px; 
    padding: 0; 
    font-family: 'Strait', sans-serif; 
     float: right; 
        float: right; 
           
    margin-right: 33px; 
   
`;

            }


            // Create NO button
            const noButton = document.createElement('button');
            noButton.style.cssText = `
    cursor: pointer; 
    background-color: transparent; 
    color: black; 
    border: 2px solid lightcoral; 
    border-radius: 50%; 
    width: 16px; 
    height: 16px; 
    padding: 0; 
    font-family: 'Strait', sans-serif; 
     float: right; 
   
    margin-right: 5px; 
`;

            // Optionally, you can add some hover effects
            yesButton.onmouseover = () => yesButton.style.backgroundColor = 'lightgreen';
            yesButton.onmouseout = () => yesButton.style.backgroundColor = 'transparent';

            noButton.onmouseover = () => noButton.style.backgroundColor = 'lightcoral';
            noButton.onmouseout = () => noButton.style.backgroundColor = 'transparent';



            // Event listener for YES button
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

            // Event listener for the yesButton
            yesButton.addEventListener('click', () => {
              line.style.transform = 'scale(0.98)';

              // Reset the transform after the animation for the pop effect
              setTimeout(() => {
                line.style.transform = 'scale(1)';
              }, 100); // Match this with the transform transition duration

              line.style.backgroundColor = 'lightgreen';

              if (!searchc.includes(color)) {
                searchc.push(color);
                // Remove the entry with (No): 🚫 + color
                searchc = searchc.filter(item => item !== `(No): 🚫 ${color}`); // Adjust based on your exact format
                updateNewCell(searchc);
              }
            });

            // Event listener for NO button
            noButton.addEventListener('click', () => {
              line.style.transform = 'scale(0.98)';

              // Reset the transform after the animation for the pop effect
              setTimeout(() => {
                line.style.transform = 'scale(1)';
              }, 100); // Match this with the transform transition duration
              line.style.backgroundColor = 'lightcoral';
              const index = searchc.indexOf(color);
              if (!searchc.includes("(No): 🚫 " + color)) {
                searchc.push("(No): 🚫 " + color);

                searchc = searchc.filter(item => item !== color); // Adjust based on your exact format

                updateNewCell(searchc);
              }
            });

            line.appendChild(yesButton);
            if (!color.includes("Optional")) {
              line.appendChild(noButton);
            }
          }

          // Append text container and buttons to line

          linesContainer.appendChild(line);
        });
        const spacer = document.createElement('div');
        spacer.style.height = '20px'; // Adjust the height as needed

        modal.appendChild(linesContainer);
        modal.appendChild(spacer);
        // Only append the lines container if the modal is empty
        //  modal.appendChild(linesContainer);
      }



      if (name.includes("Played ddBy")) {

        const characters = [
          '  ',
          'Duel Monsters',
          '🟦 Yugi Muto',
          '🟩 Joey Wheeler',
          '🟩 Seto Kaiba',

          '🟫 Mai Valentine',
          '🟫 Mako Tsunami',
          '🟫 Rex Raptor',
          '🟫 Weevil Underwood',
          '🟥 Maximillion Pegasus',
          '🟥 Yami Marik',
          '🟥 Ryo Bakura',

          '  ',
          'GX',
          '🟦 Jaden Yuki',
          '🟩 Chazz Princeton',
          '🟩 Zane Truesdale',
          '🟫 Alexis Rhodes',
          '🟫 Bastion Misawa',

          '  ',
          '5Ds',
          '🟦 Yusei Fudo',
          '🟩 Jack Atlas',
          '🟩 Crow Hogan',
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        characters.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          line.textContent = color;

          if (color !== ' ' && color !== 'Main Color' && color !== '  ' && color !== 'GX' && color !== '5Ds' && color !== 'Duel Monsters') {
            line.style.height = '30px';
            line.style.backgroundColor =
              searchc.includes(`(No): 🚫 ${color}`)
                ? 'lightcoral'
                : searchc.includes(color)
                  ? 'lightgreen'
                  : 'white';
        
          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
        
          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          }
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }


      if (name.includes("Name")) {

       const letters = [
          'Write a specific word...',
          '',
          '... or choose Keywords',

          '🅰️ One Word','🅰️🅱️ Two Words',  'A...', 'B...', 'C...', 'D...', 'E...', 'F...', 'G...', 'H...', 'I...', 'J...', 'K...', 'L...', 'M...', 'N...', 'O...', 'P...', 'Q...', 'R...', 'S...', 'T...', 'U...', 'V...', 'W...', 'X...', 'Y...', 'Z...'

        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        letters.forEach(color => {
        
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          line.textContent = color;



          if (color === 'Write a specific word...') {




            
            line.addEventListener('click', () => {
              line.textContent = "";

              // Create a wrapper for the input and button
              const inputWrapper = document.createElement('div');
              inputWrapper.style.display = 'flex'; // Use flexbox for alignment
              inputWrapper.style.alignItems = 'center'; // Center items vertically
              inputWrapper.style.opacity = '0'; // Start hidden
              // To fade in
              fadeIn(inputWrapper);



              const input = document.createElement('input');
              input.style.display = 'flex'; // Make the input a flex container
              input.style.alignItems = 'center'; // Center items vertically (not usually necessary for input)
              input.style.height = '30px'; // Match the line height
              input.style.fontSize = '12.5px'; // Match the font size
              input.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              input.style.border = '1px solid #ccc'; // Optional: border styling
              input.style.padding = '0 5px'; // Optional: padding for better aesthetics

              input.style.transition = 'background-color 0.9s ease, transform 0.7s ease';


              // Create a Send button
              const sendButton = document.createElement('button');
              sendButton.textContent = 'Send';
              sendButton.style.marginLeft = '5px'; // Add some spacing
              sendButton.style.height = '30px'; // Match height with line and input for alignment
              sendButton.style.fontSize = '12.5px'; // Match the font size
              sendButton.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              sendButton.style.border = '1px solid #ccc'; // Optional: border styling
              sendButton.style.backgroundColor = '#f0f0f0'; // Optional: background color
              sendButton.style.cursor = 'pointer'; // Change cursor on hover
              sendButton.style.padding = '0 10px'; // Optional: padding for better aesthetics
              sendButton.style.borderRadius = '4px'; // Optional: rounded corners
              sendButton.style.transition = 'background-color 1s'; // Optional: smooth background transition

              // Append the input and button to the wrapper
              inputWrapper.appendChild(input);
              inputWrapper.appendChild(sendButton);

              // Replace the line text with the input wrapper
              linesContainer.replaceChild(inputWrapper, line);

              // Focus on the input field
              input.focus();

              // Handle input submission when the input loses focus
              input.addEventListener('blur', () => {
                handleInputSubmission(input);
              });

              // Handle Enter key to submit the input
              input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  input.blur(); // Trigger blur event to save the text
                }
              });

              // Handle Send button click
              sendButton.addEventListener('click', () => {
                fadeOut(sendButton); // Fade out the send button
                input.blur(); // Trigger blur event to save the text

              });
              function handleInputSubmission(inputField) {
               
               // line.textContent = ''; // Clear the line text initially
               

                // Add text content to the array only if it's not already present
                if (!searchc.includes(inputField.value)) {
                  searchc.push("Name: " + inputField.value); // Add text content to the array
                  // Example usage: update the content of the newCell
                  updateNewCell(searchc);
                }

                fadeOut(sendButton); // Fade out the send button

                // Set a timeout to reintroduce the text with a transition
                setTimeout(() => {
                  linesContainer.replaceChild(line, inputWrapper); // Replace input wrapper with line
                  line.textContent = 'Write a specific word...'; // Set line text to input value
                  line.style.opacity = 0; // Start with the line hidden
                  // Trigger a reflow to restart the transition
                  line.offsetHeight; // This line forces a reflow
                  line.style.transition = 'opacity 0.5s'; // Set transition for opacity
                  line.style.opacity = 1; // Fade in the line
                }, 100); // Delay before showing the text
              }
            });

            line.style.backgroundColor = 'white';

            line.style.borderRadius = '10px'; // Rounded corners
            line.style.marginBottom = '15px'; // Space between lines
            line.style.padding = '0 10px'; // Padding inside the line for better text appearance

            line.style.cursor = 'pointer';
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';


            linesContainer.appendChild(line);
          }











          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";




          if (color !== '' && color !== '... or choose Keywords' && color !== 'Write a specific word...') {



          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }

          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
          line.textContent = color;

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          }
          linesContainer.appendChild(line);
        });
     
        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }





      if (name.includes("ATK / DEF")) {

        const letters = [
          '⚔️ ATK (min): ...',
          '⚔️ ATK (max): ...',
          '🛡️ DEF (min): ...',
          '🛡️ DEF (max): ...',
       
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        letters.forEach(color => {

          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          line.textContent = color;



          if (color.includes("): ...")) {





            line.addEventListener('click', () => {
              remembrance = line.textContent
              line.textContent = "";

              // Create a wrapper for the input and button
              const inputWrapper = document.createElement('div');
              inputWrapper.style.display = 'flex'; // Use flexbox for alignment
              inputWrapper.style.alignItems = 'center'; // Center items vertically
              inputWrapper.style.opacity = '0'; // Start hidden
              // To fade in
              fadeIn(inputWrapper);



              const input = document.createElement('input');
              input.style.display = 'flex'; // Make the input a flex container
              input.style.alignItems = 'center'; // Center items vertically (not usually necessary for input)
              input.style.height = '30px'; // Match the line height
              input.style.fontSize = '12.5px'; // Match the font size
              input.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              input.style.border = '1px solid #ccc'; // Optional: border styling
              input.style.padding = '0 5px'; // Optional: padding for better aesthetics

              input.style.transition = 'background-color 0.9s ease, transform 0.7s ease';


              // Create a Send button
              const sendButton = document.createElement('button');
              sendButton.textContent = 'Send';
              sendButton.style.marginLeft = '5px'; // Add some spacing
              sendButton.style.height = '30px'; // Match height with line and input for alignment
              sendButton.style.fontSize = '12.5px'; // Match the font size
              sendButton.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              sendButton.style.border = '1px solid #ccc'; // Optional: border styling
              sendButton.style.backgroundColor = '#f0f0f0'; // Optional: background color
              sendButton.style.cursor = 'pointer'; // Change cursor on hover
              sendButton.style.padding = '0 10px'; // Optional: padding for better aesthetics
              sendButton.style.borderRadius = '4px'; // Optional: rounded corners
              sendButton.style.transition = 'background-color 1s'; // Optional: smooth background transition

              // Append the input and button to the wrapper
              inputWrapper.appendChild(input);
              inputWrapper.appendChild(sendButton);

              // Replace the line text with the input wrapper
              linesContainer.replaceChild(inputWrapper, line);

              // Focus on the input field
              input.focus();

              // Handle input submission when the input loses focus
              input.addEventListener('blur', () => {
                handleInputSubmission(input);
              });

              // Handle Enter key to submit the input
              input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  input.blur(); // Trigger blur event to save the text
                }
              });

              // Handle Send button click
              sendButton.addEventListener('click', () => {
                fadeOut(sendButton); // Fade out the send button
                input.blur(); // Trigger blur event to save the text

              });

              function handleInputSubmission(inputField) {
                line.textContent = remembrance 
                line.textContent = line.textContent.replace(/(\.\.\.|[0-9]+)/g, "") + inputField.value;
                 // Set line text to input value
               
                linesContainer.replaceChild(line, inputWrapper); // Replace input wrapper with line

                // Add text content to the array only if it's not already present
                if (!searchc.includes(remembrance.replace("...", ""))) {
                  remembrance = remembrance.replace(/(\.\.\.|[0-9]+)/g, "");
                  searchc.push(remembrance.replace("...","") + inputField.value); // Add text content to the array
                  // Example usage: update the content of the newCell
                  updateNewCell(searchc);
                }
              }
            });

            line.style.backgroundColor = 'white';

            line.style.borderRadius = '10px'; // Rounded corners
            line.style.marginBottom = '15px'; // Space between lines
            line.style.padding = '0 10px'; // Padding inside the line for better text appearance

            line.style.cursor = 'pointer';
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';


            linesContainer.appendChild(line);
          }











          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";




          if (color !== '' && color !== '... or choose Keywords' && !color.includes("): ...")) {



            if (searchc.includes(color)) {
              line.style.backgroundColor = 'lightgreen';
            }
            else {
              line.style.backgroundColor = 'white';
            }

            line.style.borderRadius = '10px'; // Rounded corners
            line.style.marginBottom = '15px'; // Space between lines
            line.style.padding = '0 10px'; // Padding inside the line for better text appearance
            line.textContent = color;

            line.style.cursor = 'pointer';
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

            // Function to handle the click event
            line.addEventListener('click', () => {
              // Add the sink effect
              line.style.transform = 'scale(0.98)';

              // Reset the transform after the animation for the pop effect
              setTimeout(() => {
                line.style.transform = 'scale(1)';
              }, 100); // Match this with the transform transition duration

              if (line.style.backgroundColor === 'lightgreen') {
                line.style.backgroundColor = 'white'; // Change to the first color
                const index = searchc.indexOf(line.textContent);
                if (index > -1) {
                  searchc.splice(index, 1); // Remove the item from the Array
                }
                updateNewCell(searchc);
              } else {
                line.style.backgroundColor = 'lightgreen'; // Change to the second color

                // Add text content to the array only if it's not already present
                if (!searchc.includes(line.textContent)) {
                  searchc.push(line.textContent); // Add text content to the array
                  // Example usage: update the content of the newCell
                  updateNewCell(searchc);
                }
              }
            });
          }
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }



     


      if (name.includes("Monster Attributes")) {

        const atrbs = [
          '★ Lvl 5-6',
          '★ Lvl 4',
          '★ Lvl 5-6',
          '★ Lvl 7-8',
          '🐂 Beast',
          '🦧 Beast-Warrior',
          '💻 Cyberse',
          '🐉 Dragon',
          '🦕 Dinosaur',
          '🧚 Fairy',
          '🐟 Fish',
          '🎃 Fiend',
          '🪞 Illusion',
          '🐜 Insect',
          '🤖 Machine',
          '🔮 Psychic',
          '🌱 Plant',
          '🌋 Pyro',
          '🦎 Reptile',
          '🗿 Rock',
          '🦑 Sea Serpent',
          '🪄 Spellcaster',
          '⚡ Thunder',
          '🗡️ Warrior',
          '🐦‍🔥 Winged Beast',
          '🐉 Wyrm',
          '🧟 Zombie'
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        atrbs.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }

          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
          line.textContent = color;

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }

      if (name.includes("Card Type") ){

        const colors = [
          '🟢 Spell',
          '🟣 Trap',
          '🟨 Normal Monster',
          '🟧 Effect',
          '🟪 Fusion',
          '🟦 Ritual',
          '⬛ Xyz',
          '⬜ Synchro',
          '💫 Tuner',
          '🔶 Pendulum',
          '🔷 Link',
     


        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        colors.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }

          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
          line.textContent = color;

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          linesContainer.appendChild(line);
        });







   


















        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }













      function fadeIn(element) {
        element.style.transition = 'opacity 0.9s ease';
        element.style.opacity = '0'; // Start from fully transparent
        element.style.visibility = 'visible'; // Make it visible immediately

        requestAnimationFrame(() => {
          element.style.opacity = '1'; // Start fading in
        });
      }

      function fadeOut(element) {
        element.style.transition = 'opacity 0.2s ease';
        element.style.opacity = '1'; // Start from fully opaque

        requestAnimationFrame(() => {
          element.style.opacity = '0'; // Start fading out
        });

        // Set visibility to hidden after the fade-out transition ends
        setTimeout(() => {
          element.style.visibility = 'hidden';
        }, 200); // Match this duration with your fade-out time
      }


      if (name.includes( "Effect")) {

        const teffects = [
'Write specific effect text...',
'',
          '... or choose Keywords',
          '1️⃣ Effect: 1 Sentence',
          '2️⃣ Effect: 2 Sentences',
          '3️⃣ Effect: 3 Sentences',
          '🎁 Add',
          '🚀 Banish',
          '⛔️ Cannot be Normal Summoned',
          '🪙 Coin',
          '🎮 Control',
          '☄️ Inflict damage',
          '💥 Destroy',
          '🎲 Dice',
          '👐🏼 Discard',
          '➕ Draw',
          '🪦 Graveyard',
          '🖐🏼 From your hand',
          '🚫 Negate',
          '🎊 Special Summon',
          '🎯 Target',
          '♙ Tribute'
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        teffects.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          line.textContent = color;





          if (color === 'Write specific effect text...') {
            line.addEventListener('click', () => {
              line.textContent = "";

              // Create a wrapper for the input and button
              const inputWrapper = document.createElement('div');
              inputWrapper.style.display = 'flex'; // Use flexbox for alignment
              inputWrapper.style.alignItems = 'center'; // Center items vertically
              inputWrapper.style.opacity = '0'; // Start hidden
              // To fade in
              fadeIn(inputWrapper);



              const input = document.createElement('input');
              input.style.display = 'flex'; // Make the input a flex container
              input.style.alignItems = 'center'; // Center items vertically (not usually necessary for input)
              input.style.height = '30px'; // Match the line height
              input.style.fontSize = '12.5px'; // Match the font size
              input.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              input.style.border = '1px solid #ccc'; // Optional: border styling
              input.style.padding = '0 5px'; // Optional: padding for better aesthetics

              input.style.transition = 'background-color 0.9s ease, transform 0.7s ease';


              // Create a Send button
              const sendButton = document.createElement('button');
              sendButton.textContent = 'Send';
              sendButton.style.marginLeft = '5px'; // Add some spacing
              sendButton.style.height = '30px'; // Match height with line and input for alignment
              sendButton.style.fontSize = '12.5px'; // Match the font size
              sendButton.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              sendButton.style.border = '1px solid #ccc'; // Optional: border styling
              sendButton.style.backgroundColor = '#f0f0f0'; // Optional: background color
              sendButton.style.cursor = 'pointer'; // Change cursor on hover
              sendButton.style.padding = '0 10px'; // Optional: padding for better aesthetics
              sendButton.style.borderRadius = '4px'; // Optional: rounded corners
              sendButton.style.transition = 'background-color 1s'; // Optional: smooth background transition

              // Append the input and button to the wrapper
              inputWrapper.appendChild(input);
              inputWrapper.appendChild(sendButton);

              // Replace the line text with the input wrapper
              linesContainer.replaceChild(inputWrapper, line);

              // Focus on the input field
              input.focus();

              // Handle input submission when the input loses focus
              input.addEventListener('blur', () => {
                handleInputSubmission(input);
              });

              // Handle Enter key to submit the input
              input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  input.blur(); // Trigger blur event to save the text
                }
              });

              // Handle Send button click
              sendButton.addEventListener('click', () => {
                fadeOut(sendButton); // Fade out the send button
                input.blur(); // Trigger blur event to save the text
               
              });

              function handleInputSubmission(inputField) {

                // line.textContent = ''; // Clear the line text initially


                // Add text content to the array only if it's not already present
                if (!searchc.includes(inputField.value)) {
                  searchc.push("Effect: " + inputField.value); // Add text content to the array
                  // Example usage: update the content of the newCell
                  updateNewCell(searchc);
                }

                fadeOut(sendButton); // Fade out the send button

                // Set a timeout to reintroduce the text with a transition
                setTimeout(() => {
                  linesContainer.replaceChild(line, inputWrapper); // Replace input wrapper with line
                  line.textContent = 'Write specific effect text...'; // Set line text to input value
                  line.style.opacity = 0; // Start with the line hidden
                  // Trigger a reflow to restart the transition
                  line.offsetHeight; // This line forces a reflow
                  line.style.transition = 'opacity 0.5s'; // Set transition for opacity
                  line.style.opacity = 1; // Fade in the line
                }, 100); // Delay before showing the text
              }
     

            });



  line.style.backgroundColor = 'white';

            line.style.borderRadius = '10px'; // Rounded corners
            line.style.marginBottom = '15px'; // Space between lines
            line.style.padding = '0 10px'; // Padding inside the line for better text appearance

            line.style.cursor = 'pointer';
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

     
  linesContainer.appendChild(line);
          }
        
    
  










          if (color !== '' && color !== '... or choose Keywords' && color !== 'Write specific effect text...'){
          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }


          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          }
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }


      // Close modal when clicking outside the textbox
      modal.addEventListener('click', function (event) {
        if (event.target === modal) {
          closeModalans(); // Use closeModalans to clear the modal content
        }
      });
    }







    function indice2() {
      // Create a table element
      const table = document.createElement('table');
      table.border = '1'; // Add border to the table for visibility

      // Center the table and make it adapt to different screen sizes
      table.style.margin = '0 auto';
      table.style.width = '60%';
      table.style.borderCollapse = 'collapse';
      table.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
      table.style.borderRadius = '10px';
      table.style.overflow = 'hidden';

      // Array of names
      const names = ['Name','Card Type', 'Monster Attributes',  'ATK / DEF', 'Effect',  'Played By'];

      // Create rows with names
      names.forEach(name => {
        // Create a new row
        const row = table.insertRow();

        // Create a new cell
        const cell = row.insertCell();

        // Add the name to the cell
        cell.textContent = name;
        cell.style.fontFamily = "'Strait', sans-serif";
        // Style the cell
        cell.style.padding = '10px';
        cell.style.border = '1px solid #ddd';
        cell.style.textAlign = 'left';
        cell.style.backgroundColor = '#f9f9f9';
        cell.style.fontSize = '14px';
        cell.style.color = '#333';
        cell.style.fontWeight = 'bold';  // Set the text to bold
        cell.style.cursor = 'pointer';

        // Add hover effect using inline style
        cell.addEventListener('mouseover', () => {
          cell.style.backgroundColor = 'rgba(139, 69, 19, 0.1)'; // Light brown background
          cell.style.color = '#3e2723'; // Darker brown text color

        });

        cell.addEventListener('mouseout', () => {
          cell.style.backgroundColor = '#f9f9f9'; // Original background color
          cell.style.color = 'black'; // Original text color


        });

        cell.addEventListener('click', () => {
          showModal(name);
        });
      });   

      // Append the table to the body or another container element
      document.body.appendChild(table);
      // Append the table to the body or another container element



    }

 


    function createNewCellContainer() {
      // Create a blank row for spacing
      let blankRow = document.createElement("div");
      blankRow.style.height = "20px"; // Adjust the height as needed



      // Append the blankRow to a parent element
      document.body.appendChild(blankRow); // Replace with the appropriate parent element
      // Create the container for the new cell
      let newCellContainer = document.createElement("div");
      newCellContainer.style.display = "table";
      newCellContainer.style.margin = "20px auto"; // Center the new cell container on the screen
      newCellContainer.style.border = "1px solid black"; // Style the new cell container
      newCellContainer.style.borderRadius = '10px'; // Rounded corners
      newCellContainer.style.backgroundColor = 'white';
      // Create the new cell
      newCell = document.createElement("div");
      newCell.textContent = "Criteria will show here"; // Add content to the new cell
      newCell.style.display = "table-cell";
      newCell.style.padding = "10px"; // Adjust padding as needed
      newCell.style.textAlign = "left"; // Align the text to the left



      // Make the cell adaptive to screen sizes
      newCell.style.width = "75vw"; // Use viewport width to make it adaptive
      newCell.style.height = "10vh"; // Use viewport height to make it adaptive
      newCell.style.maxWidth = "110%"; // Ensure the width doesn't exceed 90% of the parent container
      newCell.style.maxHeight = "50vh"; // Ensure the height doesn't exceed 50% of the viewport height
      newCell.style.overflow = "auto"; // Enable scrollbars for overflow



      newCell.style.fontSize = '12.5px';
      newCell.style.fontFamily = "'Strait', sans-serif";

      // Append the new cell to the container
      newCellContainer.appendChild(newCell);

      // Append the blank row and new cell container to the body
      document.body.appendChild(blankRow);


      var button = document.createElement('button');
      button.textContent = 'Show';
      button.id = 'clickMe2Button';
      button.style.marginRight = '10px'; // Add some space before the edge
      button.style.marginBottom = '10px'; // Add some space before the edge
      button.classList.add('coolButton2'); // Add a class for styling
      // button.style.marginLeft = '12px';

      // Style the button
      button.textContent = 'Search';


      // Position the button at the bottom left of the container
      button.style.position = 'absolute'; // Absolute positioning
      button.style.bottom = '0'; // Align to the bottom
      button.style.right = '0'; // Align to the left

      // Ensure the container has relative positioning
      newCellContainer.style.position = 'relative'; // Needed for absolute positioning inside it


      // Add event listener to the button to create and add a table
      // Add event listener to the button to create and add a table
      button.addEventListener('click', function () {


      



        let flags2 = allcards.filter(flag =>
          searchc
            .filter(item =>
              item !== "Optional: Flags with the selected colors only" &&
              !item.includes("Effect: ") &&// Exclude items containing "Effect: " 
              !item.includes("Name: ") && // Exclude items containing "Effect: "
              !item.includes("⚔️ ATK (min): ") &&// Exclude items containing "Effect: "
              !item.includes("⚔️ ATK (max): ") &&// Exclude items containing "Effect: "
              !item.includes("🛡️ DEF (min): ") &&// Exclude items containing "Effect: "
              !item.includes("🛡️ DEF (max): ") // Exclude items containing "Effect: "
            &&    !item.includes("(No):") // Exclude items containing "Effect: "
            )
            .every(color =>
              flag.Items.includes(conditionated(color))
            )
        );


        flagseff = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("Effect: ")) // Filter for items containing "Effect: "
            .every(color =>
              flag.efct.toLowerCase().includes(color.replace("Effect: ", "").toLowerCase())
            )
        );
      

        flagsatkmin = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("⚔️ ATK (min): ")) // Filter for items containing "ATK (min): "
            .every(item => parseInt(flag.atkval, 10) >= parseInt(item.replace("⚔️ ATK (min): ", ""), 10)) // Use '>' for comparison
        );

        flagsatkmax = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("⚔️ ATK (max): ")) // Filter for items containing "ATK (min): "
            .every(item => parseInt(flag.atkval, 10) <= parseInt(item.replace("⚔️ ATK (max): ", ""), 10)) // Use '>' for comparison
        );

        flagsdefmin = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("🛡️ DEF (min): ")) // Filter for items containing "ATK (min): "
            .every(item => parseInt(flag.defval, 10) >= parseInt(item.replace("🛡️ DEF (min): ", ""), 10)) // Use '>' for comparison
        );

        flagsdefmax = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("🛡️ DEF (max): ")) // Filter for items containing "ATK (min): "
            .every(item => parseInt(flag.defval, 10) <= parseInt(item.replace("🛡️ DEF (max): ", ""), 10)) // Use '>' for comparison
        );



        negativeflags = allcards.filter(flag =>
          searchc.filter(item => item.includes("(No):")).every(color => {
            const conditionedColor = conditionated(color.replace("(No): 🚫 ", ""));

            return !flag.Items.includes(conditionedColor) 
          })
        );

        if (negativeflags[0] !== undefined) {
          allcards = negativeflags.filter(flag => allcards.includes(flag));
        }

        flagsname = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("Name: ")) // Filter for items containing "Effect: "
            .every(color =>
              flag.couname.toLowerCase().includes(color.replace("Name: ", "").toLowerCase())
            )
        );


        flagsaux = flagseff.filter(flag =>
          flagsname.includes(flag) && flagsatkmin.includes(flag) && flagsatkmax.includes(flag) && flagsdefmin.includes(flag) && flagsdefmax.includes(flag)
        );


        let flags = flags2.filter(flag =>
          flagsaux.includes(flag)
        );
       



        const ul = document.createElement('ul');
        ul.style.listStyleType = 'none';
        ul.style.padding = '0';
        ul.style.margin = '0';


        const li2 = document.createElement('li');

        // Set the text content for the list item
        li2.textContent = flags.length + " results";

        // Check for the number of results
        if (flags.length > 249) {
          li2.textContent = "250+ results";
        }

        // Style the list item
        li2.style.display = 'flex';
        li2.style.alignItems = 'center';
        li2.style.marginBottom = '10px'; // Optional
        li2.style.fontWeight = 'bold'; // Make the text bold

        // Create the button
        const btnback7 = document.createElement('button');
        btnback7.textContent = "Order by";
        btnback7.style.cssText = "margin-left: auto; padding: 4px 8px; background: lightgray; color: black; border: none; font-size: 10px; font-family: 'Strait', sans-serif; cursor: pointer; border-radius: 4px;";



        // Append the button to li2
        li2.appendChild(btnback7);

        // Add event listener to the button to open the modal
        btnback7.addEventListener('click', () => {
          showModalExtra("Order By", flags);

        });
        // Append li2 to the unordered list
        ul.appendChild(li2);

        

        flags.slice(0, 250).forEach(flag => {
          const li = document.createElement('li');
          li.style.display = 'flex';
          li.style.alignItems = 'center';
          li.style.marginBottom = '10px'; // Optional: add some space between list items

          // Create an anchor element for the hyperlink
          const a = document.createElement('a');
          a.href = flag.cardlink;  // Set the URL from flags.cardlink
          a.style.textDecoration = 'none';  // Remove underline from text (optional)
          a.style.color = 'inherit';  // Keep the original text color
          a.style.display = 'flex';  // Make anchor a flex container
          a.style.alignItems = 'center';  // Center items vertically in the anchor

          // Create an image element for the flag
          const img = document.createElement('img');
          img.src = flag.cardpic;
          img.alt = `${flag.couname} Flag`;
          img.style.width = '20px'; // Adjust the width as needed
          img.style.height = 'auto'; // Adjust the height as needed
          img.style.marginRight = '10px'; // Space between the image and text
          img.style.borderRadius = '10%'; // Rounded corners
          img.style.border = '1px solid #000'; // Add a border (adjust color and thickness as needed)

          // Set image to be clickable and trigger modal
          img.style.cursor = "pointer";
          img.addEventListener('click', function (e) {
            
            e.preventDefault();  // Prevent the link from being followed when clicking the image
            showmodalCard(flag);
          });

          // Append the image to the anchor
          a.appendChild(img);

          // Set the text content of the anchor
          const textNode = document.createTextNode(flag.couname );
          const atkSpan = document.createElement('span');
          atkSpan.style.marginLeft = 'auto'; // Push ATK text to the right
          atkSpan.textContent = "(☆" +`${flag.lvel}` + ") " + `${flag.atkval}` + " - " +`${flag.defval}`;
          atkSpan.style.fontSize = '0.7em'; // Set smaller font size
          a.appendChild(textNode);
          li.appendChild(a);


          if (flag.atkval!== undefined && flag.defval !== undefined){
          li.appendChild(atkSpan); // Append the ATK text after the anchor
          // Append the list item to the unordered list
          }
          ul.appendChild(li);
        });

        newCell2.textContent = "";
        newCell2.appendChild(ul);
      });


      // Append the button to the container
      newCellContainer.appendChild(button);


      document.body.appendChild(newCellContainer);
    }



    // Function to update the content of the newCell with a list of searchc entries
    function updateNewCell(searchc) {
      if (newCell2) {
        newCell2.innerHTML = ''; // Option 1: Set innerHTML to empty string

        // Option 2: Remove all child nodes
        while (newCell2.firstChild) {
          newCell2.removeChild(newCell2.firstChild);
        }
      }

      searchc.sort();
      if (newCell) {
        newCell.innerHTML = ""; // Clear the existing content
        let list = document.createElement("ul"); // Create a new list element
        list.style.listStyleType = "none"; // Remove default list styling
        list.style.padding = "0"; // Remove default padding
        list.style.textAlign = "left"; // Align the list items to the left

        searchc.forEach((item, index) => {
          let listItem = document.createElement("li"); // Create a new list item for each entry


          listItem.textContent = item; // Set the text content of the list item

          if (!item.includes("(No):")) {
            listItem.textContent = "✅ " + "\u00A0" + "\u00A0" + "\u00A0" + "\u00A0" + item; // Use quotes for the non-breaking space
          }
          else {
            listItem.textContent = "⛔️ " + "\u00A0" + "\u00A0" + "\u00A0" + "\u00A0" + item.replace("(No): 🚫", ""); // Use quotes for the non-breaking space
          }

          listItem.style.margin = "5px 0"; // Add margin between list items

          // Create a small "X" to remove the item
          let removeButton = document.createElement("span");
          removeButton.textContent = "×"; // Text for the "X"
          removeButton.style.color = "black"; // Change the color of the "X"
          removeButton.style.cursor = "pointer"; // Change cursor to pointer
          removeButton.style.marginLeft = "15px"; // Space between item text and "X"
          removeButton.style.fontWeight = "bold"; // Make the "X" bold
          removeButton.style.fontSize = "14px"; // Increase the font size
          removeButton.style.transition = "color 0.3s"; // Smooth color transition on hover
          removeButton.style.transform = "translateY(-1px)"; // Lower the "X" a tiny bit



          // Add hover effect
          removeButton.onmouseover = function () {
            removeButton.style.color = "gray"; // Change color on hover
          };

          removeButton.onmouseout = function () {
            removeButton.style.color = "black"; // Revert color when not hovering
          };

          // Add click event to remove the list item
          removeButton.onclick = function () {
            searchc.splice(index, 1); // Remove the item from searchc
            updateNewCell(searchc); // Update the displayed list
          };

          listItem.appendChild(removeButton); // Append the "X" to the list item
          list.appendChild(listItem); // Append the list item to the list

          if (listItem.textContent.includes("⛔️")) {
            listItem.style.color = "red"; // Change text color to red
          }
          else {
            listItem.style.color = "green"; // Change text color to red
          }


        });

        newCell.appendChild(list); // Append the list to the newCell
      } else {
        console.warn("newCell does not exist. Please create it first.");
      }
    }




    function createNewCellContainer2() {
      // Create a blank row for spacing

      // Create the container for the new cell
      let newCellContainer2 = document.createElement("div");
      newCellContainer2.style.display = "table";
      newCellContainer2.style.margin = "20px auto"; // Center the new cell container on the screen
      newCellContainer2.style.border = "1px solid black"; // Style the new cell container
      newCellContainer2.style.borderRadius = '10px'; // Rounded corners
      newCellContainer2.style.backgroundColor = 'white';
      // Create the new cell
      newCell2 = document.createElement("div");
      newCell2.textContent = "Results"; // Add content to the new cell
      newCell2.style.display = "table-cell";
      newCell2.style.padding = "10px"; // Adjust padding as needed
      newCell2.style.textAlign = "left"; // Align the text to the left



      // Make the cell adaptive to screen sizes
      newCell2.style.width = "75vw"; // Use viewport width to make it adaptive
      newCell2.style.height = "10vh"; // Use viewport height to make it adaptive
      newCell2.style.maxWidth = "110%"; // Ensure the width doesn't exceed 90% of the parent container
      newCell2.style.maxHeight = "50vh"; // Ensure the height doesn't exceed 50% of the viewport height
      newCell2.style.overflow = "auto"; // Enable scrollbars for overflow



      newCell2.style.fontSize = '12.5px';
      newCell2.style.fontFamily = "'Strait', sans-serif";

      // Append the new cell to the container
      newCellContainer2.appendChild(newCell2);





      document.body.appendChild(newCellContainer2);
    }



  function conditionated(critt) {
        if (critt.includes("(No):")) {critt = critt.replace("(No): 🚫", "");}
        const lookupMap = {
          // Characters
          'Yugi Muto': "anYugi",
          'Joey Wheeler [Katsuya Jonouchi]': "anYugi",
          'Seto Kaiba': "anSeto",
          'Maximillion Pegasus [Pegasus J. Crawford]': "anPega",
          'Yami Marik': "anMari",
          'Bakura': "anBaku",
          'Mai Valentine': "anMaiV",
          'Weevil Underwood': "anWeev",
          'Rex Raptor': "anRexR",

          'Jaden Yuki': "anJadn",
          'Alexis Rhodes': "anAlxs",
          'Chazz Princeton': "anChaz",
          'Zane Truesdale': "anZane",
          'Bastion Misawa': "anBast",
          'Nightshroud': "anNigh",
          'Jim Cook': "anCook",
          'Yubel': "anYubl",
          'Sartorius': "anSart",

          'Yusei Fudo': "anYuse",
          'Jack Atlas': "anJack",
          'Crow Hogan': "anCrbw",
          'Akiza Izinski': "anAkii",
          'Kalin Kessler': "anKali",
          'Yuma Tsukumo': "anYuma",

          'Yuya Sasaki': "anYuya",
          'Sylvio Sawatari': "anSylv",
          'Declan Akaba [Akaba Reiji]': "anDecl",

          'Playmaker': "anPlmk",
          'Blue Angel': "anBlue",
          'George Gore': "anGeor",
          'Soulburner': "anSoul",
          'Varis': "anVari",
          'Ai': "anAIIA",


          'anDeclan': "anDecl",


          // Card types
          '🟢 Spell': "spells",
          '🟣 Trap': "traps",
          '🟨 Normal Monster': "msNorm",
          '🟧 Effect': "msEfct",
          '🟪 Fusion': "msFuse",
          '🟦 Ritual': "msRitu",
          '⬛ Xyz': "msXYZs",
          '⬜ Synchro': "msSync",
          '💫 Tuner': "msTune",
          '🔶 Pendulum': "msPend",
          '🔷 Link': "msLink",

          // Levels
          '★ Lvl 5-6': "lvl056",

          // Word counts
          '🅰️ One Word': "words1",
          '🅰️🅱️ Two Words': "words2",

          // Starting letters
          'A...': "startA", 'B...': "startB", 'C...': "startC", 'D...': "startD",
          'E...': "startE", 'F...': "startF", 'G...': "startG", 'H...': "startH",
          'I...': "startI", 'J...': "startJ", 'K...': "startK", 'L...': "startL",
          'M...': "startM", 'N...': "startN", 'O...': "startO", 'P...': "startP",
          'Q...': "startQ", 'R...': "startR", 'S...': "startS", 'T...': "startT",
          'U...': "startU", 'V...': "startV", 'W...': "startW", 'X...': "startX",
          'Y...': "startY", 'Z...': "startZ",

          // Attack values
          '⚔️ ATK: 100-500': "AT0500",
          '⚔️ ATK: 600-1000': "AT1000",
          '⚔️ ATK: 1100-1500': "AT1500",
          '⚔️ ATK: 1500-2000': "AT2000",
          '⚔️ ATK: 2000-2500': "AT2500",
          '⚔️ ATK: 2500-3000': "AT3000",
          '⚔️ ATK: 2050-3000': "ATK200",
          '⚔️ ATK: 1050-2000': "ATK100",
          '⚔️ ATK: 50-1000': "ATK000",

          // Defense values
          '🛡️ DEF: 100-500': "DF0500",
          '🛡️ DEF: 600-1000': "DF1000",
          '🛡️ DEF: 1100-1500': "DF1500",
          '🛡️ DEF: 1500-2000': "DF2000",
          '🛡️ DEF: 2000-2500': "DF2500",
          '🛡️ DEF: 2500-3000': "DF3000",

          // Types
          '🐂 Beast': "tpBeas",
          '🦧 Beast-Warrior': "tpBewa",
          '💻 Cyberse': "tpCybe",
          '🐉 Dragon': "tpDrag",
          '🦕 Dinosaur': "tpDino",
          '🧚 Fairy': "tpFair",
          '🐟 Fish': "tpFish",
          '🎃 Fiend': "tpFien",
          '🪞 Illusion': "tpIllu",
          '🐜 Insect': "tpInse",
          '🤖 Machine': "tpMach",
          '🔮 Psychic': "tpPsyc",
          '🌱 Plant': "tpPlan",
          '🌋 Pyro': "tpPyro",
          '🦎 Reptile': "tpRept",
          '🗿 Rock': "tpRock",
          '🦑 Sea Serpent': "tpSeap",
          '🪄 Spellcaster': "tpSpel",
          '⚡ Thunder': "tpThun",
          '🗡️ Warrior': "tpWarr",
          '🐦‍🔥 Winged Beast': "tpWing",
          '🐉 Wyrm': "tpWyrm",
          '🧟 Zombie': "tpZomb",

          // Effects
          '1️⃣ Effect: 1 Sentence': "sntnc1",
          '2️⃣ Effect: 2 Sentences': "sntnc2",
          '3️⃣ Effect: 3 Sentences': "sntnc3",
          '🎁 Add': "efAdds",
          '🚀 Banish': "efBani",
          '⛔️ Cannot be Normal Summoned': "efCant",
          '🪙 Coin': "efCoin",
          '🎮 Control': "efCtrl",
          '☄️ Inflict damage': "efDamg",
          '💥 Destroy': "efDest",
          '🎲 Dice': "efDice",
          '👐🏼 Discard': "efDisc",
          '➕ Draw': "efDraw",
          '🪦 Graveyard': "efGrav",
          '🖐🏼 From your hand': "efHand",
          '🚫 Negate': "efNega",
          '🎊 Special Summon': "efSpec",
          '🎯 Target': "efTarg",
          '♙ Tribute': "efTrib",

          // Attributes
          '🌕 LIGHT': "atLIGH",
          '🌑 DARK': "atDARK",
          '💨 WIND': "atWIND",
          '🪵 EARTH': "atEART",
          '🔥 FIRE': "atFIRE",
          '💧 WATER': "atWATE",
          '☯️ DIVINE': "atDIVI"
    };
      for (const [key, value] of Object.entries(lookupMap)) {if (critt.includes(key)) {return value;}}
      return null;
    }



    function backdropping(commando) {
      if (commando === "open") {
        let backdrop = document.getElementById('modal-backdrop');
        if (!backdrop) {
          backdrop = document.createElement('div');
          Object.assign(backdrop.style, {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100vw',
            height: '100vh',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            zIndex: '1',  // Backdrop z-index
            opacity: '0',
            transition: 'opacity 0.65s',
            overflow: 'hidden'
          });
          backdrop.id = 'modal-backdrop';
          document.body.appendChild(backdrop);

          const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
          document.body.style.paddingRight = `${scrollbarWidth}px`;
          document.body.style.overflow = 'hidden';

          requestAnimationFrame(() => {
            backdrop.style.opacity = '1';
          });
        }
      }

      if (commando === "close") {
        let backdrop = document.getElementById('modal-backdrop');
        if (backdrop) {
          backdrop.style.opacity = '0'; // Fade out
          backdrop.remove();
          document.body.style.paddingRight = '';
          document.body.style.overflow = ''; // Restore body scrolling
        }
      }
    }


    //showmodalCard is the modal that appears with all the info of a card
    function showmodalCard(cardmax) {

      nameofcard = cardmax.couname
      imgofcard = cardmax.cardpic
  
      const modal = document.getElementById('modalq');
      const headline = document.getElementById('modal-headlineq');
      const btnmodal = document.getElementById('close-modalq');

      function closeModalans() {
        setTimeout(() => {
          modal.style.display = "none";
          if (modal.contains(img)) {modal.removeChild(img);}
          if (modal.contains(ul)) {modal.removeChild(ul);}
          backdropping("close")
          modal.style.display = "none";
        }, 100);
      }


      btnmodal.addEventListener("click", closeModalans);
      btnmodal.style.marginTop = '-10px'; // Adjust the value as needed to raise the button

      headline.innerHTML = nameofcard;
      headline.style.fontFamily = "'Strait', sans-serif";
      headline.style.fontSize = '15px';
      headline.style.marginTop = '10px'; // Adjust the value as needed


      const img = document.createElement('img');
      img.src = imgofcard;
      img.alt = `${nameofcard} Flag`;
      img.style.maxWidth = '100%'; // Set maximum width to 100% of modal width
      img.style.height = 'auto'; // Maintain aspect ratio
      img.height = 49*1.05;
      img.width = 67.5*1.05;
      img.style.display = 'block'; // Ensures it behaves like a block-level element
      img.style.borderRadius = '7px'; // Add rounded corners, adjust the radius as needed
      img.style.border = '2px solid black'; // Add a 1px solid black border
      img.style.cursor = "pointer";

      img.addEventListener('click', function () {
        window.open(imgofcard, '_blank');
      });
      modal.appendChild(img);

      const ul = document.createElement('ul');
      ul.style.listStyleType = 'none';
      ul.style.padding = '0'; 



      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      //Level + ATK + DEF

      if (!cardmax.Items.includes("spells") && !cardmax.Items.includes("traps")) {
      const level_0 = document.createElement('li');
        level_0.style.height = '8px';  

        const level_1 = document.createElement('li');
        level_1.innerHTML = '<strong>Level: ★ </strong> ';
        level_1.style.fontFamily = "'Strait', sans-serif";
        level_1.style.fontSize = '12px';
        level_1.innerHTML = level_1.innerHTML + cardmax.lvel 

        ul.appendChild(level_0);
        ul.appendChild(level_1);

        const atkdef_0 = document.createElement('li');
        atkdef_0.style.height = '8px';  // Adjust the height as needed
        ul.appendChild(atkdef_0);

        const atkdef_1 = document.createElement('li');
        atkdef_1.innerHTML = '<strong>ATK: ★ </strong> ';
        atkdef_1.style.fontFamily = "'Strait', sans-serif";
        atkdef_1.style.fontSize = '12px';
        atkdef_1.innerHTML = '<strong>ATK: </strong> ' + cardmax.atkval + '&nbsp;<strong>DEF: </strong> ' + cardmax.defval;

        ul.appendChild(atkdef_0);
        ul.appendChild(atkdef_1);
      }



      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      //Card Type

      const lblank = document.createElement('li');
      lblank.style.height = '8px';  // Adjust the height as needed
      ul.appendChild(lblank);
      const litems = document.createElement('li');
      litems.innerHTML = '<strong>Card Type:</strong> ';
      litems.style.fontFamily = "'Strait', sans-serif";
      litems.style.fontSize = '12px';
      var shapemax = [];
      const itemMappings = {
        "spells": "🟢 Spell",
        "traps": "🟣 Trap",
        "contns": "♾️ Continuous",
        "msPend": "🔶 Pendulum Monster",
        "msLink": "🔷 Link Monster",
        "msRitu": "🟦 Ritual Monster",
        "msSync": "⬜ Synchro Monster",
        "msXYZs": "⬛ Xyz Monster",
        "msFuse": "🟪 Fusion Monster",
        "msEfct": "🟧 Effect Monster",
        "msNorm": "🟨 Normal Monster",
        "msTune": "💫 Tuner",
        "msFlip": "↪️ Flip"
        };
      for (const [key, value] of Object.entries(itemMappings)) {if (cardmax.Items.includes(key)) {shapemax.push(value);}}
      litems.innerHTML = litems.innerHTML + shapemax.join(', ')
      ul.appendChild(litems);



      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      //Monster Attributes

      if (!cardmax.Items.includes("spells") && !cardmax.Items.includes("traps")) {
        const attribute_0 = document.createElement('li');
        attribute_0.style.height = '8px';  // Adjust the height as needed

        const attribute_1 = document.createElement('li');
        attribute_1.innerHTML = '<strong>Monster Attributes:</strong>';
        Object.assign(attribute_1.style, {
          fontFamily: "'Strait', sans-serif",
          fontSize: '12px'
        });

        const itemMap = {
          "atLIGH": "🌕 LIGHT",
          "atDARK": "🌑 DARK",
          "atWIND": "💨 WIND",
          "atEART": "🪵 EARTH",
          "atFIRE": "🔥 FIRE",
          "atWATE": "💧 WATER",
          "atDIVI": "☯️ DIVINE",
          "tpAqua": "🌊 Aqua",
          "tpBeas": "🐂 Beast",
          "tpBewa": "🦧 Beast-Warrior",
          "tpCybe": "💻 Cyberse",
          "tpDrag": "🐉 Dragon",
          "tpDino": "🦕 Dinosaur",
          "tpFair": "🧚 Fairy",
          "tpFish": "🐟 Fish",
          "tpFien": "🎃 Fiend",
          "tpIllu": "🪞 Illusion",
          "tpInse": "🐜 Insect",
          "tpMach": "🤖 Machine",
          "tpPsyc": "🔮 Psychic",
          "tpPlan": "🌱 Plant",
          "tpPyro": "🌋 Pyro",
          "tpRept": "🦎 Reptile",
          "tpRock": "🗿 Rock",
          "tpSeap": "🦑 Sea Serpent",
          "tpSpel": "🪄 Spellcaster",
          "tpThun": "⚡ Thunder",
          "tpWarr": "🗡️ Warrior",
          "tpWing": "🐦‍🔥 Winged Beast",
          "tpWyrm": "🐉 Wyrm",
          "tpZomb": "🧟 Zombie"
        };
        const itemmax = Object.keys(itemMap).filter(key => cardmax.Items.includes(key)).map(key => itemMap[key]);
        attribute_1.innerHTML += itemmax.join(', ');

        ul.appendChild(attribute_0);
        ul.appendChild(attribute_1);
      }
      



      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      // Anime Decks
      
      const animeMapping = {
        "anYugi": "Yugi",
        "anJoey": "Joey",
        "anSeto": "Kaiba",
        "anZane": "Zane",
        "anPega": 'Pegasus',
        "anMari": 'Marik',
        "anBaku": 'Bakura',
        "anMaiV": 'Mai',
        "anWeev": 'Weevil',
        "anRexR": 'Rex',

        "anJadn": 'Jaden',
        "anAlxs": 'Alexis',
        "anChaz": 'Chazz',
        "anZane": 'Zane',
        "anBast": 'Bastion',
        "anNigh": 'Nightshroud',
        "anCook": 'Jim',
        "anYubl": 'Yubel',
        "anSart": 'Sartorius',

        "anYuse": 'Yusei',
        "anJack": 'Jack',
        "anCrbw": 'Crow',
        "anAkii": 'Akiza',
        "anKali": 'Kalin',

        "anYuma": 'Yuma',

        "anYuya": 'Yuya',
        "anSylv": 'Sylvio',

        "anPlmk": 'Playmaker',
        "anBlue": 'Blue Angel',
        "anGeor": 'George Gore',
        "anSoul": 'Soulburner',
      };

      const animax = Object.keys(animeMapping).filter(key => cardmax.Items.includes(key)).map(key => animeMapping[key]);

      if (animax.length > 0) {
        const anim_0 = document.createElement('li');
        anim_0.style.height = '8px';  // Adjust the height as needed

        const anim_1 = document.createElement('li');
        anim_1.innerHTML = `<strong>Played by:</strong> ${animax.join(', ')}`;
        anim_1.style.fontFamily = "'Strait', sans-serif";
        anim_1.style.fontSize = '12px';

        ul.appendChild(anim_0);
        ul.appendChild(anim_1);
      }

      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      //Description
        const description_0 = document.createElement('li');
        description_0.style.height = '8px';  // Adjust the height as needed

        const description_1 = document.createElement('li');
        description_1.style.fontFamily = "'Strait', sans-serif";
        description_1.style.fontSize = '12px';
        description_1.innerHTML = `<strong>Effect:</strong> ${cardmax.efct || '-'}`;

        ul.appendChild(description_0);
        ul.appendChild(description_1);
      
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


      backdropping("open")

      modal.appendChild(ul);
      modal.style.display = 'block';
      Object.assign(modal.style, {
                    position: 'fixed',
                    zIndex: '1001',
                    background: 'white',
                    boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)',
                    width: '70%',
                    height: '60%',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    overflowY: 'scroll',
                    opacity: '0',
                    transition: 'opacity 1s'
      });
      modal.offsetHeight;


      setTimeout(() => {
        modal.style.opacity = '1';
      }, 10); 
    

      const style = document.createElement('style');
            style.innerHTML = `
        #modalq::-webkit-scrollbar {
            width: 8px; /* Width of the scrollbar */
        }
        #modalq::-webkit-scrollbar-thumb {
            background: #888; /* Color of the scrollbar */
            border-radius: 10px; /* Rounded corners */
        }
        #modalq::-webkit-scrollbar-thumb:hover {
            background: #555; /* Darker color on hover */
        }
        #modalq::-webkit-scrollbar-track {
            background: #f1f1f1; /* Color of the scrollbar track */
            border-radius: 10px; /* Rounded corners */
        }
      `;
      document.head.appendChild(style);
      modal.style.maxWidth = '450px'; // Width of the modal
      modal.style.maxHeight = '800px'; // Width of the modal
      document.body.appendChild(modal);

      modal.offsetHeight;
      modal.style.opacity = '1';
    }

  //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



    createNewCellContainer();
    createNewCellContainer2();
  });
