const url = 'https://raw.githubusercontent.com/zbz31/zbz31.github.io/refs/heads/main/ygjap5.txt';

async function fetchCards() {
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error('Network response was not ok');
    const data = await response.text();
    const cards = JSON.parse(data); // Parse the fetched data
    cards.sort((a, b) => parseInt(b.rank) - parseInt(a.rank)); // Sort the cards by rank
    //cards.sort((a, b) => parseInt(a.name) - parseInt(b.name)); // Sort the cards by name
    return cards;
  } catch (error) {
    console.error('Fetch error:', error);
    return [];
  }
}



      document.addEventListener("DOMContentLoaded", async () => {

        const loadingContainer = document.createElement('div');
        Object.assign(loadingContainer.style, {
                      display: 'flex',
                      justifyContent: 'center',
                      alignItems: 'flex-start',
                      height: '80vh',
                      paddingTop: '25vh'
                      });
        document.body.appendChild(loadingContainer);


        //Loading Screen
        for (let i = 0; i < 3; i++) {
          const dot = document.createElement('span');
          dot.textContent = '🟫';
          dot.style.fontSize = '15px'; // Make dots larger
          dot.style.opacity = '0.3';
          dot.style.transition = 'opacity 0.5s';
          loadingContainer.appendChild(dot);
        }
        const dots = loadingContainer.querySelectorAll('span');
        let index = 0;
        function illuminateDots() {
          dots.forEach((dot, i) => {
            dot.style.opacity = (i === index) ? '1' : '0.3';
          });
          index = (index + 1) % dots.length;
        }
        const intervalId = setInterval(illuminateDots, 200);
        const cards = await fetchCards(); // Wait for cards to be fetched
        if (cards) {
          clearInterval(intervalId); 
          loadingContainer.remove(); 
        }
        //End of loading Screen


        let answers = []
        const puzzleselection = [
            [{ order: "1", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1000", "LVL 3"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1500"] }],
            [{ order: "2", cname: "Thousand Dragon", prow: ["2400+ATK", "700-DEF", "Fusion"], pcolumn: ["Dragon", "Level 3-7", "Used by Joey"] }],
            [{ order: "3", cname: "Bad Reaction to Simochi", prow: ["Spell", "Trap", "3+Words"], pcolumn: ["Your Opponent gains LP", "Damages your opponent", "Continuous"] }],
            [{ order: "4", cname: "Pot of Greed", prow: ["Spell", "Spell", "Spell"], pcolumn: ["You Draw Cards", "You Draw Cards", "You Draw Cards"] }],
            [{ order: "5", cname: "E-HERO Clayman", prow: ["LEVEL 4", "ATK 1000-", "Elemental HERO"], pcolumn: ["Used by Jaden (ANIME)", "Normal Monster", "DEF 2000+"] }],
            [{ order: "6", cname: "Gate Guardians", prow: ["LIGHT", "WIND", "WATER"], pcolumn: ["Level 7-11", "2000+ATK", "2000+DEF"] }],
            [{ order: "7", cname: "Final Countdown", prow: ["Spell", "Spell", "Spell"], pcolumn: ["Pays LP for cost", "Duel Winner", "Starts with F"] }],
            [{ order: "8", cname: "BLS Envoy", prow: ["Cannot be Normal Summoned", "Warrior", "Effect "], pcolumn: ["LIGHT", "DARK", "3000+ATK"] }],
            [{ order: "9", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-6"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "10", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1000", "LVL 3"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1500"] }],
            [{ order: "11", cname: "Thousand Dragon", prow: ["2400+ATK", "700-DEF", "Fusion"], pcolumn: ["Dragon", "Level 3-7", "Used by Joey"] }],
            [{ order: "12", cname: "Bad Reaction to Simochi", prow: ["Spell", "Trap", "3+Words"], pcolumn: ["Your Opponent gains LP", "Damages your opponent", "Continuous"] }],
            [{ order: "13", cname: "Pot of Greed", prow: ["Spell", "Spell", "Spell"], pcolumn: ["You Draw Cards", "You Draw Cards", "You Draw Cards"] }],
            [{ order: "14", cname: "E-HERO Clayman", prow: ["LEVEL 4", "ATK 1000-", "Elemental HERO"], pcolumn: ["Used by Jaden (ANIME)", "Normal Monster", "DEF 2000+"] }],
            [{ order: "15", cname: "Gate Guardians", prow: ["LIGHT", "WIND", "WATER"], pcolumn: ["Level 7-11", "2000+ATK", "2000+DEF"] }],
            [{ order: "16", cname: "Final Countdown", prow: ["Spell", "Spell", "Spell"], pcolumn: ["Pays LP for cost", "Duel Winner", "Starts with F"] }],
            [{ order: "17", cname: "BLS Envoy", prow: ["Cannot be Normal Summoned", "Warrior", "Effect "], pcolumn: ["LIGHT", "DARK", "3000+ATK"] }],
            [{ order: "18", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-6"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "19", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-7"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "20", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-8"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "21", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-9"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "22", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-10"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "23", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-11"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "24", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-12"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "25", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-13"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "26", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-14"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "27", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-15"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "28", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-16"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "29", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-17"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "30", cname: "Jinzo", prow: ["2400+ATK", "1500+DEF", "Level 5-18"], pcolumn: ["One Word", "DARK", "used by Joey"] }],
            [{ order: "31", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1000", "LVL 3"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1500"] }],
            [{ order: "32", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1001", "LVL 4"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1501"] }],
            [{ order: "33", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1002", "LVL 5"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1502"] }],
            [{ order: "34", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1003", "LVL 6"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1503"] }],
            [{ order: "35", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1004", "LVL 7"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1504"] }],
            [{ order: "36", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1005", "LVL 8"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1505"] }],
            [{ order: "37", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1006", "LVL 9"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1506"] }],
            [{ order: "38", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1007", "LVL 10"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1507"] }],
            [{ order: "39", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1008", "LVL 11"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1508"] }],
            [{ order: "40", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1009", "LVL 12"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1509"] }],
            [{ order: "41", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1010", "LVL 13"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1510"] }],
            [{ order: "42", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1011", "LVL 14"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1511"] }],
            [{ order: "43", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1012", "LVL 15"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1512"] }],
            [{ order: "44", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1013", "LVL 16"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1513"] }],
            [{ order: "45", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1014", "LVL 17"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1514"] }],
            [{ order: "46", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1015", "LVL 18"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1515"] }],
            [{ order: "47", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1016", "LVL 19"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1516"] }],
            [{ order: "48", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1017", "LVL 20"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1517"] }],
            [{ order: "49", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1018", "LVL 21"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1518"] }],
            [{ order: "50", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1019", "LVL 22"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1519"] }],
            [{ order: "51", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1020", "LVL 23"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1520"] }],
            [{ order: "52", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1021", "LVL 24"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1521"] }],
            [{ order: "53", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1022", "LVL 25"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1522"] }],
            [{ order: "54", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1023", "LVL 26"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1523"] }],
            [{ order: "55", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1024", "LVL 27"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1524"] }],
            [{ order: "56", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1025", "LVL 28"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1525"] }],
            [{ order: "57", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1026", "LVL 29"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1526"] }],
            [{ order: "58", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1027", "LVL 30"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1527"] }],
            [{ order: "59", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1028", "LVL 31"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1528"] }],
            [{ order: "60", cname: "Exodia", prow: ["AT1000", "ATK: 300-1029", "LVL 32"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1529"] }],
            [{ order: "61", cname: "Exodia", prow: ["AT1000", "ATK: 300-1030", "LVL 33"], pcolumn: ["anJoey", "anJoey", "anJoey"] }],
            [{ order: "62", cname: "Exodia", prow: ["AT1000", "ATK: 300-1031", "LVL 34"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1531"] }],
            [{ order: "63", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1032", "LVL 35"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1532"] }],
            [{ order: "64", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1033", "LVL 36"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1533"] }],
            [{ order: "65", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1034", "LVL 37"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1534"] }],
            [{ order: "66", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1035", "LVL 38"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1535"] }],
            [{ order: "67", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1036", "LVL 39"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1536"] }],
            [{ order: "68", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1037", "LVL 40"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1537"] }],
            [{ order: "69", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1038", "LVL 41"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1538"] }],
            [{ order: "70", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1039", "LVL 42"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1539"] }],
            [{ order: "71", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1040", "LVL 43"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1540"] }],
            [{ order: "72", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1041", "LVL 44"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1541"] }],
            [{ order: "73", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1042", "LVL 45"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1542"] }],
            [{ order: "74", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1043", "LVL 46"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1543"] }],
            [{ order: "75", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1044", "LVL 47"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1544"] }],
            [{ order: "76", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1045", "LVL 48"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1545"] }],
            [{ order: "77", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1046", "LVL 49"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1546"] }],
            [{ order: "78", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1047", "LVL 50"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1547"] }],
            [{ order: "79", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1048", "LVL 51"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1548"] }],
            [{ order: "80", cname: "Exodia", prow: ["efGrav", "efBani", "startA"], pcolumn: ["efSumm", "anJoey", "spells"] }],
            [{ order: "81", cname: "Exodia", prow: ["startA", "efGrav", "AT1500"], pcolumn: ["anJoey", "anJoey", "efGrav"] }],
            [{ order: "82", cname: "Exodia", prow: ["AT2000", "efGrav", "AT1500"], pcolumn: ["anJoey", "AT1000", "anSeto"] }],
            [{ order: "83", ctry: "Kuriboh", prow: ["startK", "words1", "ATK000"], pcolumn: ["anYugi", "anYugi", "anYugi"] }],
            [{ order: "84", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1052", "LVL 55"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1552"] }],
            [{ order: "85", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1054", "LVL 57"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1554"] }],
            [{ order: "86", ctry: "Dark Magician", prow: ["msNorm", "tpSpel", "ATK200"], pcolumn: ["DF2500", "startD", "anYugi"] }],
            [{ order: "87", ctry: "Jinzo", prow: ["msEfct", "words1", "ATK200"], pcolumn: ["lvl056", "startJ", "anJoey"] }],
            [{ order: "88", ctry: "Jack's Knight", prow: ["lvl056", "tpWarr", "msNorm"], pcolumn: ["AT2000", "startJ", "anYugi"] }],
            [{ order: "89", ctry: "Pot of Greed", prow: ["anSeto", "anJoey", "efDraw"], pcolumn: ["anYugi", "spells", "startP"] }],
            [{ order: "90", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1059", "LVL 62"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1559"] }],
            [{ order: "91", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1060", "LVL 63"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1560"] }],
            [{ order: "92", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1061", "LVL 64"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1561"] }],
            [{ order: "93", ctry: "Dark Magician", prow: ["msNorm", "tpSpel", "ATK200"], pcolumn: ["DF2500", "startD", "anYugi"] }],
            [{ order: "94", ctry: "Jack's Knight", prow: ["lvl056", "tpWarr", "msNorm"], pcolumn: ["AT2000", "startJ", "anYugi"] }],
            [{ order: "95", ctry: "Stardust Dragon", prow: ["efSpec", "msSync", "tpDrag"], pcolumn: ["startS", "efTrib", "efNega"] }],
            [{ order: "96", ctry: "Legendary Six Samurai - Shi En", prow: ["tpWarr", "lvl056", "efNega"], pcolumn: ["msSync", "efDest", "startL"] }],
            [{ order: "97", ctry: "Garoozis", prow: ["words1", "startG", "msNorm"], pcolumn: ["anJoey", "AT2000", "lvl056"] }],
            [{ order: "98", ctry: "Red-Eyes Black Dragon", prow: ["anJoey", "startR", "tpDrag"], pcolumn: ["msNorm", "ATK200", "lvl078"] }],
            [{ order: "99", ctry: "Obelisk the Tormentor", prow: ["anYugi", "efTrib", "efTarg"], pcolumn: ["anSeto", "atDIVI", "efDest"] }],
            [{ order: "100", ctry: "Judgment Dragon", prow: ["efPays", "efDest", "efSend"], pcolumn: ["atLIGH", "tpDrag", "AT3000"] }],
            [{ order: "101", ctry: "Pot of Greed", prow: ["spells", "startP", "anYugi"], pcolumn: ["efDraw", "anJoey", "anSeto"] }],
            [{ order: "102", ctry: "Wulf, Lightsworn Beast", prow: ["atLIGH", "AT2500", "efGrav"], pcolumn: ["lvl004", "efSend", "efSpec"] }],
            [{ order: "103", ctry: "Number 39: Utopia", prow: ["startN", "AT2500", "tpWarr"], pcolumn: ["msXYZs", "msXYZs", "msXYZs"] }],
            [{ order: "104", ctry: "Dandylion", prow: ["words1", "efGrav", "tpPlan"], pcolumn: ["msEfct", "lvl023", "efSpec"] }],
            [{ order: "105", ctry: "Catapult Turtle", prow: ["tpAqua", "anYugi", "startC"], pcolumn: ["efTrib", "lvl056", "msEfct"] }],
            [{ order: "106", ctry: "Cyber Dragon", prow: ["startC", "startC", "startC"], pcolumn: ["tpMach", "AT2500", "lvl056"] }],
            [{ order: "107", ctry: "Formula Synchron", prow: ["msTune", "efDraw", "tpMach"], pcolumn: ["msSync", "ATK000", "lvl023"] }],
            [{ order: "108", ctry: "Skull Servant", prow: ["msNorm", "ATK000", "words2"], pcolumn: ["startS", "lvl001", "tpZomb"] }],
            [{ order: "109", ctry: "Perfectly Ultimate Great Moth", prow: ["msEfct", "lvl078", "efSpec"], pcolumn: ["tpInse", "AT3500", "efTrib"] }],
            [{ order: "110", ctry: "Elder Entity Norden", prow: ["efNega", "startE", "msFuse"], pcolumn: ["efGrav", "efSpec", "lvl004"] }],
            [{ order: "111", ctry: "Elemental HERO Sparkman", prow: ["anHERO", "tpWarr", "AT2000"], pcolumn: ["atLIGH", "msNorm", "lvl004"] }],
            [{ order: "112", ctry: "Gaia the Dragon Champion", prow: ["startG", "tpDrag", "AT3000"], pcolumn: ["msFuse", "anYugi", "lvl078"] }],
            [{ order: "113", ctry: "Gearfried the Iron Knight", prow: ["startG", "tpWarr", "lvl004"], pcolumn: ["anJoey", "msEfct", "efDest"] }],
            [{ order: "114", ctry: "Junk Synchron", prow: ["msTune", "efGrav", "efNega"], pcolumn: ["efSpec", "lvl023", "tpWarr"] }],
            [{ order: "115", ctry: "Thousand Dragon", prow: ["anJoey", "AT2500", "tpDrag"], pcolumn: ["startT", "msFuse", "DF2000"] }],
            [{ order: "116", ctry: "Maxx C", prow: ["efSpec", "msEfct", "ATK000"], pcolumn: ["startM", "tpInse", "efDraw"] }],
            [{ order: "117", ctry: "Breaker the Magical Warrior", prow: ["tpSpel", "msEfct", "lvl004"], pcolumn: ["efCter", "efTarg", "efDest"] }],
            [{ order: "118", ctry: "Enemy Controller", prow: ["spells", "anJoey", "efTarg"], pcolumn: ["anSeto", "startE", "efTrib"] }],
            [{ order: "119", ctry: "Mokey Mokey", prow: ["startM", "startM", "startM"], pcolumn: ["words2", "lvl001", "ATK000"] }],
            [{ order: "120", ctry: "Effect Veiler", prow: ["AT0000", "efTarg", "efSend"], pcolumn: ["lvl001", "efNega", "atLIGH"] }],
            [{ order: "121", ctry: "Musician King", prow: ["msFuse", "words2", "AT2000"], pcolumn: ["startM", "lvl056", "atLIGH"] }],
            [{ order: "122", ctry: "Dark Armed Dragon", prow: ["atDARK", "tpDrag", "lvl078"], pcolumn: ["startD", "efSpec", "efDest"] }],
            [{ order: "123", ctry: "Dark World Dealings", prow: ["spells", "spells", "startD"], pcolumn: ["efDraw", "efDisc", "words3"] }],
            [{ order: "124", ctry: "Man-Eater Bug", prow: ["f_Damag", "msFlip", "efTarg"], pcolumn: ["AT0500", "lvl023", "efDest"] }],
            [{ order: "125", ctry: "Big Shield Gardna", prow: ["f_field", "DF3000", "startB"], pcolumn: ["AT0500", "tpWarr", "lvl004"] }],
            [{ order: "126", ctry: "Elemental HERO Neos", prow: ["msNorm", "AT2500", "lvl078"], pcolumn: ["anHERO", "words3", "atLIGH"] }],
            [{ order: "127", ctry: "Pot of Greed", prow: ["efDraw", "efDraw", "anJoey"], pcolumn: ["spells", "anYugi", "anSeto"] }],
            [{ order: "128", ctry: "Battle Ox", prow: ["startB", "tpBeas", "msNorm"], pcolumn: ["lvl004", "anSeto", "AT2000"] }],
            [{ order: "129", ctry: "Five-Headed Dragon", prow: ["tpDrag", "tpDrag", "msFuse"], pcolumn: ["tpDrag", "tpDrag", "tpDrag"] }],
            [{ order: "130", ctry: "The Seal of Orichalcos", prow: ["spells", "namae_S", "namae_O"], pcolumn: ["anMaiV", "anRexR", "anWeev"] }],
            [{ order: "131", ctry: "Magician of Faith", prow: ["tpSpel", "efTarg", "efGrav"], pcolumn: ["anYugi", "msFlip", "efAdds"] }],
            [{ order: "132", ctry: "Dark Hole", prow: ["spells", "startD", "anYugi"], pcolumn: ["efDest", "efDest", "efDest"] }],
            [{ order: "133", ctry: "XYZ-Dragon Cannon", prow: ["startX", "startY", "startZ"], pcolumn: ["anSeto", "msEfct", "msEfct"] }],
            [{ order: "134", ctry: "Wulf, Lightsworn Beast", prow: ["efSend", "efSend", "efSend"], pcolumn: ["atLIGH", "atLIGH", "atLIGH"] }],
            [{ order: "135", ctry: "La Jinn the Mystical Genie of the Lamp", prow: ["anSeto", "msNorm", "startL"], pcolumn: ["atDARK", "lvl004", "ATK100"] }],
            [{ order: "136", ctry: "Elemental HERO Flame Wingman", prow: ["anHERO", "efDest", "efDamg"], pcolumn: ["msFuse", "lvl056", "AT2500"] }],
            [{ order: "137", ctry: "Green Gadget", prow: ["startG", "startY", "startR"], pcolumn: ["anYugi", "tpMach", "lvl004"] }],
            [{ order: "138", ctry: "Alpha The Magnet Warrior", prow: ["startA", "startB", "startG"], pcolumn: ["anYugi", "msNorm", "lvl004"] }],
            [{ order: "139", ctry: "Solemn Warning", prow: ["traps", "efNega", "words2"], pcolumn: ["startS", "startS", "startS"] }],
            [{ order: "140", ctry: "Polymerization", prow: ["anYugi", "anJoey", "startP"], pcolumn: ["anSeto", "spells", "words1"] }],
            [{ order: "141", ctry: "Magician of Black Chaos", prow: ["msRitu", "atDARK", "lvl078"], pcolumn: ["anYugi", "tpSpel", "ATK200"] }],
            [{ order: "142", ctry: "Dragon Zombie", prow: ["words2", "atDARK", "AT2000"], pcolumn: ["tpDrag", "tpZomb", "startD"] }],
            [{ order: "143", ctry: "Thunder Dragon", prow: ["startT", "startT", "startT"], pcolumn: ["words2", "lvl056", "tpThun"] }],
            [{ order: "107", ctry: "Gearfried the Iron Knight", prow: ["startG", "tpWarr", "lvl004"], pcolumn: ["anJoey", "msEfct", "efDest"] }],
            [{ order: "113", ctry: "Marshmallon", prow: ["msEfct", "lvl023", "ATK000"], pcolumn: ["efCant", "efDamg", "anYugi"] }],
            [{ order: "119", ctry: "Gorz the Emissary of Darkness", prow: ["atDARK", "efToke", "efDamg"], pcolumn: ["msEfct", "lvl078", "efSpec"] }],
            [{ order: "102", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1071", "LVL 74"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1571"] }],
            [{ order: "103", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1072", "LVL 75"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1572"] }],
            [{ order: "104", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1073", "LVL 76"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1573"] }],
            [{ order: "105", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1074", "LVL 77"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1574"] }],
            [{ order: "106", cname: "Exodia", prow: ["Effect Monster", "ATK: 300-1075", "LVL 78"], pcolumn: ["attribute: DARK", "attype: Spellcaster", "DEF: 1000-1575"] }],
            [{ order: "122", ctry: "Gagaga Cowboy", prow: ["DF2500", "startG", "efDamg"], pcolumn: ["lvl004", "msXYZs", "words2"] }],
            [{ order: "122", ctry: "Destiny Draw", prow: ["efDisc", "efDraw", "startD"], pcolumn: ["spells", "spells", "words2"] }],
            [{ order: "122", ctry: "Treeborn Frog", prow: ["efOnce", "atWATE", "lvl001"], pcolumn: ["efSpec", "msEfct", "words2"] }],
          [{ order: "130", ctry: "Giant Soldier of Stone", prow: ["tpRock", "msNorm", "namae_Gagaga"], pcolumn: ["anYugi", "AT1500", "atEART"] }],
          [{ order: "130", ctry: "Dark Magician", prow: ["tpSpel", "msNorm", "namae_Dark"], pcolumn: ["anYugi", "ATK200", "atDARK"] }],

          ]




    let currentYugiPuzzle = todayPuzzle()[0].order;
    let currentYugiGrid = []

    initLocalStorage();
    let puzzleYugiGrid = {order: currentYugiPuzzle.toString(),row1col1: "",row1col2: "",row1col3: "",row2col1: "",row2col2: "",row2col3: "",row3col1: "",row3col2: "",row3col3: "",};
    if (currentYugiGrid.find(item => item.order === currentYugiPuzzle.toString()) !== undefined) {
      puzzleYugiGrid = currentYugiGrid.find(item => item.order === currentYugiPuzzle.toString());
    }

    initHelpModal();
    initHelpModal2();
    puzzle1 = puzzleselection[currentYugiPuzzle - 1]
    createGrid(puzzle1);
    window.localStorage.setItem('currentYugiPuzzle', todayPuzzle()[0].order)
    window.localStorage.setItem('currentYugiArchive', "no");
    solved()


    function initLocalStorage() {

      const storedcurrentYugiPuzzle = window.localStorage.getItem('currentYugiPuzzle');
      if (!storedcurrentYugiPuzzle) {
        window.localStorage.setItem('currentYugiPuzzle', currentYugiPuzzle);
      } else {
        currentYugiPuzzle = storedcurrentYugiPuzzle;
      }

      const storedcurrentYugiGrid = window.localStorage.getItem('current4YugiGrid');
      if (!storedcurrentYugiGrid) {
        window.localStorage.setItem('current4YugiGrid', currentYugiGrid);
      } else {
        currentYugiGrid = JSON.parse(storedcurrentYugiGrid);
      }

      if (!storedcurrentYugiGrid) {
        window.localStorage.setItem('current4YugiGrid', currentYugiGrid);
      } else {
        currentYugiGrid = JSON.parse(storedcurrentYugiGrid);
      }
      const storedYugiArchive = window.localStorage.getItem('currentYugiArchive');
      if (storedYugiArchive === "no") {
        currentYugiPuzzle = todayPuzzle()[0].order;

      }
      if (!storedYugiArchive) {
        window.localStorage.setItem('currentYugiArchive', "no");
      }
    }


    function analyzeCondition(conditn) {
      //code
      const conditionsMap = {
        "rgn_": "region",
        "cl_": "Colors",
        "f_": "efct",
        "namae_": "couname"
      };
      for (const key in conditionsMap) 
      {if (conditn.includes(key)) 
      {return conditionsMap[key]}}
      return "Items";
    }
 
    function chequeo(condit) {
      //code
      var rr = analyzeCondition(condit[0]); var cc = analyzeCondition(condit[1]);
      function includesCaseInsensitive(container, value) {
        if (typeof container === 'string') {
          return container.toLowerCase().includes(value.toLowerCase());
        }
        return Array.isArray(container) && container.some(element =>
          element.toLowerCase().includes(value.toLowerCase())
        );
      }
      checkd = cards.filter(item =>
        includesCaseInsensitive(item[rr], takeCategory(condit[0])) &&
        includesCaseInsensitive(item[cc], takeCategory(condit[1]))
      );
      return checkd
    }


      function initHelpModal() {
        const modal = document.getElementById("help-modal");
        const btn = document.getElementById("help-button"); // Get the button that opens the modal
        const span = document.getElementById("close-help");  // Get the <span> element that closes the modal
        const modalContent = document.querySelector(".modalhelp-content"); // Get modal content

    function openModal() {

      modal.style.display = "block";
      setTimeout(() => {
        modalContent.classList.add("show"); // Add class to show modal content with smooth transition
        backdropping("open")
      }, 30);
    }

    function closeModal() {
      modalContent.classList.remove("show"); // Remove class to hide modal content with smooth transition
      setTimeout(() => {
        modal.style.display = "none";
      }, 300); // Delay hiding the modal to ensure smooth transition completion
    }

    btn.addEventListener("click", openModal);

    span.addEventListener("click", closeModal);

    window.addEventListener("click", function (event) {   // When the user clicks anywhere outside of the modal, close it
      if (event.target == modal) {
        closeModal();
      }
    });
  }

  function createGrid(puzzle1) {

    let gridCells = [];
    const gridContainer = document.getElementById('gridContainer');


    for (let row = 0; row < 4; row++) {
      for (let col = 0; col < 4; col++) {
        const cell = document.createElement("div");
        cell.dataset.row = row;
        cell.dataset.col = col;
        formatGridCell(puzzle1, row, col, cell)
        gridContainer.appendChild(cell);
        gridCells.push(cell);

      }
    }
    createbuttonGiveUp(puzzle1);
    createbuttonClear();
    createDisclaimer();
  }



  function isNameInObject(data, searchName) {
    for (const key in data) {

      if (data[key] && data[key].name && data[key].name.toLowerCase() === searchName.toLowerCase()) {
        return true;
      }
    }
    return false;
  }



  //transformOrTransfer modifies the condition of the puzzle and converts into emoji-like values in the grid and a description

    function transformOrTransfer(key, formatType) {
    if (key.includes('f_')) {
      const specificMap = {"f_": ["Effect:...", "🟫<br>Effect:<br>'" + key.charAt(2).toUpperCase() + key.slice(3) + "'", "<br>The card effect contains the indicated word(s)"]};
      return specificMap["f_"] ? specificMap["f_"][formatType] : "Unknown type";
    }
    if (key.includes('namae_')) {
      const specificMap = { "namae_": ["Name:...", "🔤<br>Name has:<br>'" + key.slice(6) + "'", "<br>The card name contains the indicated letter(s)"]};
      return specificMap["namae_"] ? specificMap["namae_"][formatType] : "Unknown type";
    }

    const combinedMappings = {
      
      //Number of words
      "words1": ["🅰️ 1 Word", "🅰️<br>Name:<br>1 Word", "<br>The card name only has one word"],
      "words2": ["🅰️🅱️ 2 Words", "🅰️🅱️<br>Name:<br>2 Words", "<br>The card name is composed of exactly two words"],
      "words3": ["🅰️🅱️🅰️ 3 Words", "🅰️🅱️🅰️<br>Name:<br>3 Words", "<br>The card name is composed of exactly three words"],

      //Starts with
      "startA": ["A...", "🅐<br>Starts with: 'A'", "<br>The card name starts with the indicated letter"],
      "startB": ["B...", "🅑<br>Starts with: 'B'", "<br>The card name starts with the indicated letter"],
      "startC": ["C...", "🅒<br>Starts with: 'C'", "<br>The card name starts with the indicated letter"],
      "startD": ["D...", "🅓<br>Starts with: 'D'", "<br>The card name starts with the indicated letter"],
      "startE": ["E...", "🅔<br>Starts with: 'E'", "<br>The card name starts with the indicated letter"],
      "startF": ["F...", "🅕<br>Starts with: 'F'", "<br>The card name starts with the indicated letter"],
      "startG": ["G...", "🅖<br>Starts with: 'G'", "<br>The card name starts with the indicated letter"],
      "startH": ["H...", "🅗<br>Starts with: 'H'", "<br>The card name starts with the indicated letter"],
      "startI": ["I...", "🅘<br>Starts with: 'I'", "<br>The card name starts with the indicated letter"],
      "startJ": ["J...", "🅙<br>Starts with: 'J'", "<br>The card name starts with the indicated letter"],
      "startK": ["K...", "🅚<br>Starts with: 'K'", "<br>The card name starts with the indicated letter"],
      "startL": ["L...", "🅛<br>Starts with: 'L'", "<br>The card name starts with the indicated letter"],
      "startM": ["M...", "🅜<br>Starts with: 'M'", "<br>The card name starts with the indicated letter"],
      "startN": ["N...", "🅝<br>Starts with: 'N'", "<br>The card name starts with the indicated letter"],
      "startO": ["O...", "🅞<br>Starts with: 'O'", "<br>The card name starts with the indicated letter"],
      "startP": ["P...", "🅟<br>Starts with: 'P'", "<br>The card name starts with the indicated letter"],
      "startQ": ["Q...", "🅠<br>Starts with: 'Q'", "<br>The card name starts with the indicated letter"],
      "startR": ["R...", "🅡<br>Starts with: 'R'", "<br>The card name starts with the indicated letter"],
      "startS": ["S...", "🅢<br>Starts with: 'S'", "<br>The card name starts with the indicated letter"],
      "startT": ["T...", "🅣<br>Starts with: 'T'", "<br>The card name starts with the indicated letter"],
      "startU": ["U...", "🅤<br>Starts with: 'U'", "<br>The card name starts with the indicated letter"],
      "startV": ["V...", "🅥<br>Starts with: 'V'", "<br>The card name starts with the indicated letter"],
      "startW": ["W...", "🅦<br>Starts with: 'W'", "<br>The card name starts with the indicated letter"],
      "startX": ["X...", "🅧<br>Starts with: 'X'", "<br>The card name starts with the indicated letter"],
      "startY": ["Y...", "🅨<br>Starts with: 'Y'", "<br>The card name starts with the indicated letter"],
      "startZ": ["Z...", "🅩<br>Starts with: 'Z'", "<br>The card name starts with the indicated letter"],

      //Level categories
      "lvl001": ["★ Lvl 1", "★<br>Level:<br>1", "<br>Monster is level 1"],
      "lvl023": ["★ Lvl 2-3", "★<br>Level:<br>2-3", "<br>Monster is level 2-3"],
      "lvl004": ["★ Lvl 4", "★<br>Level:<br>4", "<br>Monster is level 4"],
      "lvl056": ["★ Lvl 5-6", "★<br>Level:<br>5-6", "<br>Monster is level 5 or 6"],
      "lvl078": ["★ Lvl 7-8", "★<br>Level:<br>7-8", "<br>Monster is level 7 or 8"],

      //ATK Values
      "ATK300": ["⚔️ ATK: 100-500", "⚔️<br>ATK:<br>100-500", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "AT0000": ["⚔️ ATK: 0", "⚔️<br>ATK:<br>0", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "AT0500": ["⚔️ ATK: 100-500", "⚔️<br>ATK:<br>100-500", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "AT1000": ["⚔️ ATK: 600-1000", "⚔️<br>ATK:<br>600-1000", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "AT1500": ["⚔️ ATK: 1100-1500", "⚔️<br>ATK:<br>1100-1500", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "AT2000": ["⚔️ ATK: 1600-2000", "⚔️<br>ATK:<br>1600-2000", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "AT2500": ["⚔️ ATK: 2100-2500", "⚔️<br>ATK:<br>2100-2500", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "AT3000": ["⚔️ ATK: 2600-3000", "⚔️<br>ATK:<br>2600-3000", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "AT3500": ["⚔️ ATK: 3100-3500", "⚔️<br>ATK:<br>3100-3500", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "ATK200": ["⚔️ ATK: 2000-3000", "⚔️<br>ATK:<br>2000-3000", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "ATK100": ["⚔️ ATK: 1050-2000", "⚔️<br>ATK:<br>1050-2000", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "ATK000": ["⚔️ ATK: 50-1000", "⚔️<br>ATK:<br>50-1000", "<br>The attack value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],

      //DEF Values
      "DF0000": ["🛡️ DEF: 0", "🛡️<br>DEF:<br>0", "<br>The defense value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "DF0500": ["🛡️ DEF: 100-500", "🛡️<br>DEF:<br>100-500", "<br>The defense value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "DF1000": ["🛡️ DEF: 600-1000", "🛡️<br>DEF:<br>600-1000", "<br>The defense value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "DF1500": ["🛡️ DEF: 1100-1500", "🛡️<br>DEF:<br>1100-1500", "<br>The defense value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "DF2000": ["🛡️ DEF: 1500-2000", "🛡️<br>DEF:<br>1500-2000", "<br>The defense value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "DF2500": ["🛡️ DEF: 2000-2500", "🛡️<br>DEF:<br>2000-2500", "<br>The defense value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],
      "DF3000": ["🛡️ DEF: 2500-3000", "🛡️<br>DEF:<br>2500-3000", "<br>The defense value of the card is contained within the indicated range<br><br>Both upper and lower bounds are also included"],

      //Anime cards
      "anJoey": ["🟨🟩Joey", "🟨🟩<br>Played by: Joey", "<br>The card was in Joey Wheeler's deck in any duel of the original anime series"],
      "anSeto": ["🟫⬜️Kaiba", "🟫⬜️<br>Played by: Kaiba", "<br>The card was in Seto Kaiba's deck in any duel of the original anime series"],
      "anYugi": ["🟥🟦Yugi", "🟥🟦<br>Played by: Yugi", "<br>The card was in Seto Kaiba's deck in any duel of the original anime series"],
      "anMaiV": ["Mai", "🟣<br>Played by: Mai", "<br>The card was in Seto Kaiba's deck in any duel of the original anime series"],
      "anWeev": ["Weevil", "🔴<br>Played by: Weevil", "<br>The card was in Seto Kaiba's deck in any duel of the original anime series"],
      "anRexR": ["Rex", "🔴<br>Played by: Rex", "<br>The card was in Seto Kaiba's deck in any duel of the original anime series"],

      "anHERO": ["🌃 E-HERO", "🌃<br>Elemental HERO", "<br>The card effect contains the indicated word(s)"],

      //Non-monster Cards
      "spells": ["🟩Spell", "🟩<br>Spell card", "<br>The card is a Spell card<br><br>Can be of any type (normal, quick-play, continuous...)"],
      "traps": ["🟪Trap", "🟪<br>Trap card", "<br>The card is a Trap card<br><br>Can be of any type (normal, counter, continuous...)"],
      "contns": ["♾️ Continuous", "♾️<br>Continuous", "<br>The card is a continuous Spell/Trap card."],

      //Type of Monster
      "msPend": ["🔶Pendulum", "🔶<br>Pendulum<br>Monster", "<br>The card is a Pendulum Monster<br><br>It does not necessarily have to be only a Pendulum type monster"],
      "msLink": ["🔷 Link", "🔷<br>Link<br>Monster", "<br>The card is a Link Monster<br><br>It does not necessarily have to be a Link-only type monster"],
      "msRitu": ["🟦 Ritual", "🟦<br>Ritual<br>Monster", "<br>The card is a Ritual Monster<br><br>It does not necessarily have to be a Ritual-only type monster"],
      "msSync": ["⬜ Synchro", "⬜<br>Synchro<br>Monster", "<br>The card is a Synchro Monster<br><br>It does not necessarily have to be a Synchro-only type monster"],
      "msXYZs": ["⬛ Xyz", "⬛<br>Xyz<br>Monster", "<br>The card is an Xyz Monster<br><br>It does not necessarily have to be an Xyz-only type monster"],
      "msFuse": ["🟪🟪 Fusion", "🟪🟪<br>Fusion<br>Monster", "<br>The card is a Fusion Monster<br><br>It does not necessarily have to be a Fusion type monster"],
      "msEfct": ["🟧 Effect", "🟧<br>Effect<br>Monster", "<br>The card is an Effect Monster<br><br>It does not necessarily have to be an Effect-only type monster"],
      "msNorm": ["🟨 Normal", "🟨<br>Normal<br>Monster", "<br>The card is a Normal Monster<br><br>It does not necessarily have to be a Normal-only type monster"],
      "msTune": ["💫 Tuner", "💫<br>Tuner<br>Monster", "<br>The card is a Tuner Monster"],
      "msFlip": ["↪️ Flip", "↪️<br>Flip<br>Monster", "<br>The card is a Flip Monster"],

      //Predetermined effects
      "efAdds": ["🎁 Add", "🎁<br>Effect:<br>'Add'", "<br>The card effect contains the indicated word(s)"],
      "efBani": ["🚀 Banish", "🚀<br>Effect:<br>'Banish'", "<br>The card effect contains the indicated word(s)"],
      "efCant": ["🕊 Cannot be destroyed", "🕊<br>Effect:<br>'Cannot be destroyed'", "<br>The card effect contains the indicated word(s)"],
      "efCter": ["🀄️ Counter", "🀄️<br>Effect:<br>'Counter'", "<br>The card effect contains the indicated word(s)"],
      "efNoss": ["⛔️ Cannot be Normal Summoned", "⛔️<br>Effect:<br>'Cannot be Normal Summoned'", "<br>The card effect contains the indicated word(s)"],
      "efCoin": ["🪙 Coin", "🪙<br>Effect:<br>'Coin'", "<br>The card effect contains the indicated word(s)"],
      "efCtrl": ["🎮 Control", "🎮<br>Effect:<br>'Control'", "<br>The card effect contains the indicated word(s)"],
      "efDamg": ["☄️ Damage", "☄️<br>Effect:<br>'Damage'", "<br>The card effect contains the indicated word(s)"],
      "efDest": ["🌀 Destroy", "🌀<br>Effect:<br>'Destroy'", "<br>The card effect contains the indicated word(s)"],
      "efDice": ["🎲 Dice", "🎲<br>Effect:<br>'Dice'", "<br>The card effect contains the indicated word(s)"],
      "efDisc": ["👐🏼 Discard", "👐🏼<br>Effect:<br>'Discard'", "<br>The card effect contains the indicated word(s)"],
      "efDraw": ["➕ Draw", "➕<br>Effect:<br>'Draw'", "<br>The card effect contains the indicated word(s)"],
      "efGrav": ["🪦 Graveyard", "🪦<br>Effect:<br>'Graveyard'", "<br>The card effect contains the indicated word(s)"],
      "efHand": ["🖐🏼 From your hand", "🖐🏼<br>Effect:<br>'From your hand'", "<br>The card effect contains the indicated word(s)"],
      "efNega": ["🚫 Negate", "🚫<br>Effect:<br>'Negate'", "<br>The card effect contains the indicated word(s)"],
      "efSend": ["📨 Send", "📨 <br>Effect:<br>'Send'", "<br>The card effect contains the indicated word(s)"],
      "efPays": ["📉 Pay", "📉 <br>Effect:<br>'Pay'", "<br>The card effect contains the indicated word(s)"],
      "efToke": ["🐏 Token", "🐏<br>Effect:<br>'Token'", "<br>The card effect contains the indicated word(s)"],
      "efSpec": ["🎊 Special Summon", "🎊<br>Effect:<br>'Special Summon'", "<br>The card effect contains the indicated word(s)"],
      "efTarg": ["🎯 Target", "🎯<br>Effect:<br>'Target'", "<br>The card effect contains the indicated word(s)"],
      "efTrib": ["♙ Tribute", "♙<br>Effect:<br>'Tribute'", "<br>The card effect contains the indicated word(s)"],
      "efOnce": ["1️⃣ Once", "1️⃣<br>Effect:<br>'Once'", "<br>The card effect contains the indicated word(s)"],
      "efDeck": ["🟫 Deck", "🟫<br>Effect:<br>'Deck'", "<br>The card effect contains the indicated word(s)"],
      "efHand": ["✋ Hand", "✋<br>Effect:<br>'Hand'", "<br>The card effect contains the indicated word(s)"],
      "sntnc1": ["1️⃣ 1 Sentence", "1️⃣<br>Effect:<br>One Sentence", "<br>Length of the effect text is only one sentence<br><br>Only text separated by a dot is considered a sentence"],
      "sntnc2": ["2️⃣ 2 Sentences", "2️⃣<br>Effect:<br>Two Sentences", "<br>Length of the effect text is two sentences<br><br>Only text separated by a dot is considered a sentence"],
      "sntnc3": ["3️⃣ 3 Sentences", "3️⃣<br>Effect:<br>Three Sentences", "<br>Length of the effect text is three sentences<br><br>Only text separated by a dot is considered a sentence"],

      //Monster Attribute
      "atLIGH": ["🌕 LIGHT", "🌕<br>Attribute:<br>LIGHT", "<br>The monster's attribute is LIGHT"],
      "atDARK": ["🌑 DARK", "🌑<br>Attribute:<br>DARK", "<br>The monster's attribute is DARK"],
      "atWIND": ["💨 WIND", "💨<br>Attribute:<br>WIND", "<br>The monster's attribute is WIND"],
      "atEART": ["🪵 EARTH", "🪵<br>Attribute:<br>EARTH", "<br>The monster's attribute is EARTH"],
      "atFIRE": ["🔥 FIRE", "🔥<br>Attribute:<br>FIRE", "<br>The monster's attribute is FIRE"],
      "atWATE": ["💧 WATER", "💧<br>Attribute:<br>WATER", "<br>The monster's attribute is WATER"],
      "atDIVI": ["☯️ DIVINE", "☯️<br>Attribute:<br>DIVINE", "<br>The monster's attribute is DIVINE"],

      //Monster Type
      "tpAqua": ["🌊 Aqua", "🌊<br>Type: Aqua", "<br>Monster's type is: Beast"],
      "tpBeas": ["🐂 Beast", "🐂<br>Type: Beast", "<br>Monster's type is: Beast"],
      "tpBewa": ["🦧 Beast-Warrior", "🦧<br>Type: Beast-Warrior", "<br>Monster's type is: Beast-Warrior"],
      "tpCybe": ["💻 Cyberse", "💻<br>Type: Cyberse", "<br>Monster's type is: Cyberse"],
      "tpDrag": ["🐉 Dragon", "🐉<br>Type: Dragon", "<br>Monster's type is: Dragon"],
      "tpDino": ["🦕 Dinosaur", "🦕<br>Type: Dinosaur", "<br>Monster's type is: Dinosaur"],
      "tpFair": ["🧚 Fairy", "🧚<br>Type: Fairy", "<br>Monster's type is: Fairy"],
      "tpFish": ["🐟 Fish", "🐟<br>Type: Fish", "<br>Monster's type is: Fish"],
      "tpFien": ["🎃 Fiend", "🎃<br>Type: Fiend", "<br>Monster's type is: Fiend"],
      "tpIllu": ["🪞 Illusion", "🪞<br>Type: Illusion", "<br>Monster's type is: Illusion"],
      "tpInse": ["🐜 Insect", "🐜<br>Type: Insect", "<br>onster's type is: Insect"],
      "tpMach": ["🤖 Machine", "🤖<br>Type: Machine", "<br>Monster's type is: Machine"],
      "tpPsyc": ["🔮 Psychic", "🔮<br>Type: Psychic", "<br>Monster's type is: Psychic"],
      "tpPlan": ["🌱 Plant", "🌱<br>Type: Plant", "<br>Monster's type is: Plant"],
      "tpPyro": ["🌋 Pyro", "🌋<br>Type: Pyro", "<br>Monster's type is: Pyro"],
      "tpRept": ["🦎 Reptile", "🦎<br>Type: Reptile", "<br>Monster's type is: Reptile"],
      "tpRock": ["🗿 Rock", "🗿<br>Type: Rock", "<br>Monster's type is: Rock"],
      "tpSeap": ["🦑 Sea Serpent", "🦑<br>Type: Sea Serpent", "<br>Monster's type is: Sea Serpent"],
      "tpSpel": ["🪄 Spellcaster", "🪄<br>Type: Spellcaster", "<br>Monster's type is: Spellcaster"],
      "tpThun": ["⚡ Thunder", "⚡<br>Type: Thunder", "<br>Monster's type is: Thunder"],
      "tpWarr": ["🗡️ Warrior", "🗡️<br>Type: Warrior", "<br>Monster's type is: Warrior"],
      "tpWing": ["🐦‍🔥 Winged Beast", "🐦‍🔥<br>Type: Winged Beast", "<br>Monster's type is: Winged Beast"],
      "tpWyrm": ["🐉 Wyrm", "🐉<br>Type: Wyrm", "<br>Monster's type is: Wyrm"],
      "tpZomb": ["🧟 Zombie", "🧟<br>Type: Zombie", "<br>Monster's type is: Zombie"]
    };
      return combinedMappings[key] ? combinedMappings[key][formatType] : "Unknown type";
      }


      function formatGridCell(puzzle1, row, col, cell) {

    row = row * 1;
    col = col * 1;
    if (row > 0 && col > 0) {
      cell.innerHTML = "";
      cell.classList.add("grid-playercell");

      if (puzzleYugiGrid["row" + row + "col" + col].status === "w") {

        const img = document.createElement("img");
        img.src = cards.find(card => card.couname === puzzleYugiGrid["row" + row + "col" + col].name).cardpic;
        cell.textContent = " "
        img.width = 61.14;
        img.height = 85;
        img.style.borderRadius = "10%";
        img.style.filter = "blur(0.5px)"; // Adjust the blur radius as needed
        cell.appendChild(img);
        cell.classList.remove("grid-playercell");
        cell.classList.add("grid-cellsolved");

        if (puzzleYugiGrid["row" + row + "col" + col].name === puzzle1[0].ctry) {
          cell.classList.remove("grid-cellsolved");
          cell.classList.add("grid-cellfod");
          img.style.filter = 'brightness(1.5) hue-rotate(45deg)';
          img.classList.add('sparkle');
          cell.addEventListener('click', () => {
            const gridCellssolved2 = document.querySelectorAll('.grid-cellsolved, .grid-cellfod');
            const gridCellsunsolved2 = document.querySelectorAll('.grid-cellunsolved');
            if ((Array.from(cell.classList).join(' ').includes('grid-cellfod') || Array.from(cell.classList).join(' ').includes('grid-cellsolved')) && gridCellssolved2.length + gridCellsunsolved2.length < 9) {
              showmodalCard(cards.find(card => card.couname === puzzleYugiGrid["row" + row + "col" + col].name));
            }});}}

      if (puzzleYugiGrid["row" + row + "col" + col].status === "e") {

        const img = document.createElement("img");
        img.src = cards.find(card => card.couname === puzzleYugiGrid["row" + row + "col" + col].name).cardpic;

        cell.textContent = " "
        img.width = 61.14;
        img.height = 85;
        img.style.borderRadius = "10%";
        img.style.filter = 'grayscale(100%) brightness(0.5) blur(0.5px)'; // Convert image to black and white and darken it


        cell.classList.remove("grid-playercell");
        cell.classList.add("grid-cellunsolved");
        cell.appendChild(img);
        cell.addEventListener('click', () => {

          showModal2(puzzle1, row, col, cell);

        }); // Added a closing parenthesis here
      }

      cell.addEventListener('click', () => {


        const gridCellssolved2 = document.querySelectorAll('.grid-cellsolved, .grid-cellfod');
        const gridCellsunsolved2 = document.querySelectorAll('.grid-cellunsolved');


        if ((Array.from(cell.classList).join(' ') === ('grid-cellunsolved') || Array.from(cell.classList).join(' ') === ('grid-cellsolved')) && gridCellssolved2.length + gridCellsunsolved2.length < 9) {

    //      showmodalCard(cards.find(card => card.couname === puzzleYugiGrid["row" + row + "col" + col].name));
        }

        if (cell.textContent === '' && Array.from(cell.classList).join(' ') === ('grid-playercell')) {
          showModal(puzzle1, row, col, cell);
        }
      });
    }


    if ((row === 0 && col === 0)) {

      cell.classList.add("grid-cellnumber");
      cell.textContent = '#' + puzzle1[0].order;

      cell.style.padding = '0'; // Remove padding to fill the entire cell
      cell.addEventListener("click", showModal4);
      cell.style.cursor = "pointer";
    }


    // These lines create the columns

    if ((row === 0 && col === 1) || (row === 0 && col === 2) || (row === 0 && col === 3)) {
      cell.classList.add("grid-puzzlecell");
      cell.style.cursor = 'pointer';
      cell.addEventListener('click', () => {

        showModalQuestion(puzzle1, row, col, cell);

      });


      cell.innerHTML = transformOrTransfer(puzzle1[0].pcolumn[col - 1], 1)
      cell.style.border = 'none';
    }
    if ((row === 1 && col === 0) || (row === 2 && col === 0) || (row === 3 && col === 0)) {
      cell.classList.add("grid-puzzlecell");
      cell.style.cursor = 'pointer';
      cell.addEventListener('click', () => {
        showModalQuestion(puzzle1, row, col, cell);
      });
      cell.innerHTML = transformOrTransfer(puzzle1[0].prow[row - 1], 1)
      cell.style.border = 'none';
    }



  }



  ///////////////////////////////////////////////////////////





  //      09-A.  CREATE BUTTON GIVE UP
  //           -This function makes a button that will be used to solve all cells
  ///////////////////////////////////////////////////////////

  function createbuttonGiveUp(puzzle1) {

    z = puzzle1
    var button = document.createElement('button');
    button.textContent = 'GIVE UP';
    button.id = 'clickMeButton';

    // Style the button for positioning and appearance
    button.style.position = 'fixed';
    button.style.bottom = '-16%'; // Adjust as needed
    button.style.right = '1vw'; // Adjust as needed
    button.style.marginRight = '2px'; // Add some space before the edge
    button.classList.add('coolButton'); // Add a class for styling
    document.getElementById('gridContainer').appendChild(button);
    button.addEventListener('click', handleClick);
  }

  function handleClick() {
    // Select all grid cells
    const gridCells = document.querySelectorAll('.grid-playercell');

    // Loop through each grid cell and set its text content to "ERROR"
    gridCells.forEach(cell => {
      addTexttoCellWRONG(cell, "-")
      cell.textContent = ""
      cell.addEventListener('click', () => {


        showModal2(z, cell.dataset.row, cell.dataset.col, cell);

      });

    });
    solved()

  }

  ///////////////////////////////////////////////////////////




  //      09-B.  CREATE BUTTON CLEAR
  //           -This function makes a button that will be used to solve all cells
  ///////////////////////////////////////////////////////////

  function createbuttonClear() {
    var button = document.createElement('button');
    button.textContent = 'CLEAR';
    button.id = 'clickMe2Button';

    // Style the button for positioning and appearance
    button.style.position = 'fixed';
    button.style.bottom = '-16%'; // Adjust as needed
    button.style.left = '1vw'; // Adjust as needed
    button.style.marginLeft = '2px'; // Add some space before the edge
    button.classList.add('coolButton'); // Add a class for styling
    document.getElementById('gridContainer').appendChild(button);

    button.addEventListener('click', function () {


      currentYugiGrid = currentYugiGrid.filter(item => item.order !== currentYugiPuzzle.toString());


      window.localStorage.setItem('current4YugiGrid', JSON.stringify(currentYugiGrid));

      setTimeout(function () {

        window.location.href = window.location.href;
      }, 300); // 2000 milliseconds = 2 seconds
    });
  }


  ///////////////////////////////////////////////////////////




        function createDisclaimer() {
          const coolText = document.createElement("p");
          coolText.innerHTML = `
          <span style='color: blue;'>NEW: A batch of high-difficulty bonus puzzles will be added this weekend</span><br><br>
          All cards within this site belong to Konami. We are an unofficial source<br>
          This site only uses first-party cookies to save answers from the user<br><br><br>`;

          document.getElementById('gridContainer').appendChild(coolText);
          Object.assign(coolText.style, {
                        position: 'fixed',
                        left: '50%',
                        bottom: '-63%',
                        transform: 'translate(-50%, -50%)',
                        textAlign: 'center',
                        width: '100%', 
                        fontFamily: 'Roboto, sans-serif',
                        fontSize: '9px', 
                        marginBottom: '10%' 
                        })
        }



        function addTexttoCellWRONG(cell, text) {
          if (cell.textContent == "") { cell.textContent = text; // Set the text content of the cell directly
                                        cell.classList.remove("grid-cell");
                                        cell.classList.add("grid-cellunsolved");
                                        answers.push("ERROR")
        }}

        function handleSearchInput(puzzle1, row, col, cell) {
          const searchInput = document.getElementById("textInput");
          const searchTerm = searchInput.value.trim()
          
          if (searchTerm.length > 0) {populateNameList(puzzle1, searchTerm, row, col, cell);}

          else                       {const nameList = document.getElementById("nameListguess");
                                      nameList.innerHTML = "";}
        }





        function countWStatsForOrder(data, order, letterstat) {

          for (let i = 0; i < data.length; i++) {
            if (data[i] && data[i].order === order) {
              let wCount = 0;
              if (data[i].row1col1 && typeof data[i].row1col1 === 'object' && data[i].row1col1.status === letterstat) {wCount++;}
              if (data[i].row2col1 && typeof data[i].row2col1 === 'object' && data[i].row2col1.status === letterstat) {wCount++;}
              if (data[i].row3col1 && typeof data[i].row3col1 === 'object' && data[i].row3col1.status === letterstat) {wCount++;}
              if (data[i].row1col2 && typeof data[i].row1col2 === 'object' && data[i].row1col2.status === letterstat) {wCount++;}
              if (data[i].row2col2 && typeof data[i].row2col2 === 'object' && data[i].row2col2.status === letterstat) {wCount++;}
              if (data[i].row3col2 && typeof data[i].row3col2 === 'object' && data[i].row3col2.status === letterstat) {wCount++;}
              if (data[i].row1col3 && typeof data[i].row1col3 === 'object' && data[i].row1col3.status === letterstat) {wCount++;}
              if (data[i].row2col3 && typeof data[i].row2col3 === 'object' && data[i].row2col3.status === letterstat) {wCount++;}
              if (data[i].row3col3 && typeof data[i].row3col3 === 'object' && data[i].row3col3.status === letterstat) {wCount++;}
              return wCount;
            }
          }
          return 0;
        }


        function takeCategory(category) {
          if (category.includes("f_")) {
            return category.slice(2); // Remove the first two characters
          } 
        else if (category.includes("namae_")) {
            return category.slice(6); // Remove the first two characters
          } 
          
          else {
            return category;
          }
        }


  function populateNameList(puzzle1, filter, row, col, cell) {
    const nameList = document.getElementById("nameList");
    nameList.innerHTML = "";
    let count = 0; // Counter for tracking the number of names added
    const normalizedFilter = filter.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
    cards.filter(item => {
      const normalizedName = item.couname.toLowerCase().normalize("NFD").replace(/[\u0300-\u036f]/g, "");
      return normalizedName.includes(normalizedFilter);
    })
      .forEach(item => {

        if (count < 20 && !isNameInObject(puzzleYugiGrid, item.couname)) {
          var li = document.createElement("li");

          li.innerHTML = `${item.couname} `;
          li.addEventListener('click', () => {
            // When a suggestion is clicked, populate the input field with the clicked name
            document.getElementById('textInput').value = item.couname;
            // Clear the suggestion list
            nameList.innerHTML = "";
            const rr = analyzeCondition(puzzle1[0].prow[row - 1]);
            const cc = analyzeCondition(puzzle1[0].pcolumn[col - 1]);

            function includesCaseInsensitive(container, value) {
              if (typeof container === 'string') {
                return container.toLowerCase().includes(value.toLowerCase());
              }
              return Array.isArray(container) && container.some(element =>
                element.toLowerCase().includes(value.toLowerCase())
              );
            }

            if (
              includesCaseInsensitive(item[rr], takeCategory(puzzle1[0].prow[row - 1])) &&
              includesCaseInsensitive(item[cc], takeCategory(puzzle1[0].pcolumn[col - 1]))
            ) {






              cell.classList.remove("grid-playercell");
              cell.classList.add("grid-cellsolved");
              puzzleYugiGrid["row" + row + "col" + col] = {
                name: item.couname,
                status: "w"
              };

              if (cell.textContent == "") {
                // Apply the class changes and image addition with a delay

                cell.classList.remove("grid-playercell");
                cell.classList.add("grid-cellsolved");

                const img = document.createElement("img");
                img.src = item.cardpic;
                img.width = 61.14;
                img.height = 85;
                img.style.borderRadius = "5%";
                img.style.filter = "blur(0.5px)"; // Adjust the blur radius as needed

                // Clear existing text content
                cell.textContent = " ";

                // Append the image to the cell
                cell.appendChild(img);

                // Update the current grid data
                let found = false;
                for (let i = 0; i < currentYugiGrid.length; i++) {
                  if (currentYugiGrid[i].order === currentYugiPuzzle) {
                    currentYugiGrid[i]["row" + row + "col" + col] = puzzleYugiGrid["row" + row + "col" + col];
                    found = true;
                    break;
                  }
                }

                if (!found) {
                  currentYugiGrid.push(puzzleYugiGrid);
                }

                window.localStorage.setItem('current4YugiGrid', JSON.stringify(currentYugiGrid));

                // Check if the country name matches and update class
                if (item.couname === puzzle1[0].ctry) {
                  cell.classList.remove("grid-cellsolved");
                  cell.classList.add("grid-cellfod");


                  if (img) {
                    // Set initial styles for shimmering effect
                    img.style.transition = 'filter 0.5s ease, opacity 0.5s ease';
                    img.style.filter = 'brightness(1.1) hue-rotate(45deg)';

                    // Create a shimmering effect using setInterval
                    let shimmerInterval = setInterval(() => {
                      img.style.filter = img.style.filter.includes('brightness(1.2)')
                        ? 'brightness(1.8) hue-rotate(45deg)'
                        : 'brightness(1.2) hue-rotate(45deg)';
                      img.style.opacity = img.style.opacity === '1' ? '0.7' : '1';
                    }, 300); // Adjust the interval time for the shimmer speed

                    // Optional: Clear the interval after some time (e.g., 3 seconds)
                    setTimeout(() => {
                      clearInterval(shimmerInterval);
                      img.style.filter = 'brightness(1.1) hue-rotate(45deg)'; // Reset to original
                      img.style.opacity = '1'; // Reset opacity
                    }, 1500); // Adjust time as needed
                  }

                }


              }
              answers.push(item.couname)

            } else {
              cell.classList.remove("grid-cell");
              cell.classList.add("grid-cellunsolved");
              const img = document.createElement("img");
              img.src = item.cardpic
              img.width = 61.14;
              img.height = 85;
              img.style.borderRadius = "40%";
              cell.textContent = " ";
              img.style.borderRadius = "5%";
              img.style.filter = "blur(0.5px)"; // Adjust the blur radius as needed
              img.style.width = '100%'; // Make the image fill the cell
              img.style.height = 'auto'; // Keep the height proportional
              img.style.borderRadius = '10%'; // Set border radius
              img.style.filter = 'grayscale(100%) brightness(0.5) blur(0.5px)'; // Convert image to black and white and darken it

              cell.appendChild(img);

              answers.push("ERROR")


              puzzleYugiGrid["row" + row + "col" + col] = {
                name: item.couname,
                status: "e"
              };
              let found = false;
              for (let i = 0; i < currentYugiGrid.length; i++) {
                if (currentYugiGrid[i].order === currentYugiPuzzle) {
                  currentYugiGrid[i]["row" + row + "col" + col] = puzzleYugiGrid["row" + row + "col" + col];
                  found = true;
                  break;
                }
              }

              if (found != true) {
                currentYugiGrid.push(puzzleYugiGrid);
              }

              window.localStorage.setItem('current4YugiGrid', JSON.stringify(currentYugiGrid));
            }

            cell.addEventListener('click', () => {
              const gridCellssolved2 = document.querySelectorAll('.grid-cellsolved, .grid-cellfod');
              const gridCellsunsolved2 = document.querySelectorAll('.grid-cellunsolved');
              if ((Array.from(cell.classList).join(' ').includes('grid-cellunsolved') || Array.from(cell.classList).join(' ').includes('grid-cellsolved')) && gridCellssolved2.length + gridCellsunsolved2.length < 9) {

                showmodalCard(cards.find(card => card.couname === item.couname));
              }
            });

            modal.style.display = 'none';
            solved()
          });
          nameList.appendChild(li);
          cell.addEventListener('click', () => {
            if (cell.textContent === " ") {

              showModal2(puzzle1, row, col, cell);
            }
          });

          count++; // Increment the count of added names
        }
      });
  }


        function backdropping(commando) {
          if (commando === "open") {
            let backdrop = document.getElementById('modal-backdrop');
            if (!backdrop) {
              backdrop = document.createElement('div');
              Object.assign(backdrop.style, {
                position: 'fixed',
                top: '0',
                left: '0',
                width: '100vw',
                height: '100vh',
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                zIndex: '1',  // Backdrop z-index
                opacity: '0',
                transition: 'opacity 0.55s',
                overflow: 'hidden'
              });
              backdrop.id = 'modal-backdrop';
              document.body.appendChild(backdrop);

              const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
              document.body.style.paddingRight = `${scrollbarWidth}px`;
              document.body.style.overflow = 'hidden';

              requestAnimationFrame(() => {
                backdrop.style.opacity = '1';
              });
            }
          }

          if (commando === "close") {
            let backdrop = document.getElementById('modal-backdrop');
            if (backdrop) {
              backdrop.style.opacity = '0'; // Fade out
              backdrop.remove();
              document.body.style.paddingRight = '';
              document.body.style.overflow = ''; // Restore body scrolling
            }
          }
        }


      //showModalQuestion is the modal that appears when you click on each category
        function showModalQuestion(puzzle1, row, col, cell) {

          const modal = document.getElementById('modalq');
          const headline = document.getElementById('modal-headlineq');
          const btnmodal = document.getElementById('close-modalq');

          function closeModalans() {
            setTimeout(() => {
              modal.style.display = "none";
            }, 100);
          }

          btnmodal.addEventListener("click", closeModalans);
          btnmodal.style.marginTop = '-10px';

          cell.addEventListener('click', () => {
            if (cell.textContent === '') { showModal(puzzle1, row, col, cell); }
          });

          headline.innerHTML = cell.innerHTML;
          headline.style.fontFamily = "'Strait', sans-serif";
          headline.style.fontSize = '12.5px';
          headline.style.marginTop = '10px';

          const additionalText = document.createElement('div');
          Object.assign(additionalText.style, {
            fontFamily: "'Strait', sans-serif",
            fontSize: '12px',
            fontWeight: 'normal',
            marginTop: '0px'
          });

          if ((row === 0 && col === 1) || (row === 0 && col === 2) || (row === 0 && col === 3)) {
            additionalText.innerHTML = transformOrTransfer(puzzle1[0].pcolumn[col - 1], 2);
          } else if ((row === 1 && col === 0) || (row === 2 && col === 0) || (row === 3 && col === 0)) {
            additionalText.innerHTML = transformOrTransfer(puzzle1[0].prow[row - 1], 2);
          }

          headline.appendChild(additionalText);
          modal.style.display = 'block';
          modal.style.opacity = '0';
          modal.offsetHeight; // Trigger reflow

          Object.assign(modal.style, {
            transition: 'opacity 0.65s',
            opacity: '1',
            width: '65%',
            height: '65%',
            top: '50%', // Centering adjustments
            left: '50%',
            transform: 'translate(-50%, -50%)',
            zIndex: '2' // Modal z-index should be greater than backdrop
          });

          modal.addEventListener('click', function (event) {
            if (event.target === modal) {
              modal.style.display = 'none';
            }
          });
        }
        
      //!! End of showModalQuestion



      //showModal is the modal that appears when you click to introduce an answer
        function showModal(puzzle1, row, col, cell) {
          const modal = document.getElementById('modal');
          const textInput = document.getElementById('textInput');
          const headline = document.getElementById('modal-headline');
          const btnmodal = document.getElementById('close-ans');

          function closeModalans() {
            setTimeout(() => {
              modal.style.display = "none";
            }, 100); 
          }

          btnmodal.addEventListener("click", closeModalans);
          btnmodal.style.marginTop = '-10px'; // Adjust the value as needed to raise the button
          document.getElementById("textInput").addEventListener("input", function () {
            handleSearchInput(puzzle1, row, col, cell);
          });
          textInput.value = ''; 
          rowcondition = puzzle1[0].prow[row - 1]
          colcondition = puzzle1[0].pcolumn[col - 1]
          if (rowcondition.length === 3) {
            rowcondition = countries.find(country => country.cname === rowcondition).cfullname
          }
          if (colcondition.length === 3) {
            colcondition = countries.find(country => country.cname === colcondition).cfullname
          }

          headline.textContent = (transformOrTransfer(rowcondition, 0) + " / " + transformOrTransfer(colcondition, 0));
          headline.style.fontFamily = "'Strait', sans-serif";
          headline.style.fontSize = '12.5px';
          headline.style.marginTop = '10px'; 

          modal.style.display = 'block';
          modal.style.opacity = '0';
          modal.offsetHeight;
          Object.assign(modal.style, {
                              transition: 'opacity 0.65s',
                              opacity: '1',
                              width: '65%',
                              height: '65%',
                              top: '60%',
                              left: '60%',
                              transform: 'translate(-50%, -50%)'
          });

          textInput.focus();
          textInput.addEventListener('keydown', function (event) {
            if (event.key === 'Escape') {modal.style.display = 'none';}
              window.addEventListener('click', function (event) {
              if (event.target === modal) {modal.style.display = 'none';}});});

          modal.addEventListener('click', function (event) {
            if (event.target === modal) {modal.style.display = 'none';}});

          }
        //!! End of showModal


       //showModal2 is the modal that appears when you click after solving the puzzle
          function showModal2(puzzle1, row, col, cell) {
            const gridCellssolved2 = document.querySelectorAll('.grid-cellsolved, .grid-cellfod');
            const gridCellsunsolved2 = document.querySelectorAll('.grid-cellunsolved');


            if (gridCellssolved2.length + gridCellsunsolved2.length === 9) {

              const condit = [puzzle1[0].prow[row - 1], puzzle1[0].pcolumn[col - 1]];

              const itemsWithBothTeams = chequeo(condit);

              const modal2 = document.getElementById('modal2');
              const modal2Content = document.getElementById("nameElement");
              const btnmodal2 = document.getElementById('close-modal2');
              const headline2 = document.getElementById('modal-headline2');
              function closeModalans2() {
                setTimeout(() => {
                  modal2.style.display = "none";
                }, 100); // Delay hiding the modal to ensure smooth transition completion
              }

              btnmodal2.addEventListener("click", closeModalans2);
              btnmodal2.style.marginTop = '-10px'; // Adjust the value as needed to raise the button



              // Clear previous content
              modal2Content.innerHTML = '';
              let playerCount = 0;


              for (const item of itemsWithBothTeams) {
                if (playerCount >= 150) {
                  break; 
                }

                const lio = document.createElement("li");

                lio.style.display = 'flex'; // Use flexbox for alignment
                lio.style.alignItems = 'center'; // Center items vertically

                const img = document.createElement('img');
                img.src = item.cardpic;
                img.alt = `${item.couname} Card`;

                img.style.height = '20px'; // Adjust the height as needed
                img.style.width = 'auto'; // Adjust the width as needed
                img.style.marginRight = '10px'; // Space between the image and text
                img.style.borderRadius = '10%'; // Rounded corners
                img.style.border = '1px solid #000'; // Add a border (adjust color and thickness as needed)

                // Append the image to the list item
                lio.appendChild(img);
                lio.innerHTML += `${item.couname}`

                document.querySelector("ul").appendChild(lio);
                lio.style.padding = '6px'; 
                lio.style.lineHeight = '1.1';  


                lio.addEventListener('click', function () {
                  // Close modal when clicking on list item
                showmodalCard(item)
                });

                modal2Content.appendChild(lio);
                playerCount++;
              }
              modal2Content.style.height = 'auto'; // Reset to auto before appending
              modal2Content.style.maxHeight = '300px'; // Set maximum height
              modal2Content.style.overflowY = 'auto'; // Allow scrolling if needed


              rowcondition = puzzle1[0].prow[row - 1]
              colcondition = puzzle1[0].pcolumn[col - 1]
              if (rowcondition.length === 3) {

                rowcondition = countries.find(country => country.cname === rowcondition).cfullname
              }

              if (colcondition.length === 3) {

                colcondition = countries.find(country => country.cname === colcondition).cfullname
              }
              headline2.textContent = (
                transformOrTransfer(rowcondition, 0) + " / " +
                transformOrTransfer(colcondition, 0));

              headline2.style.fontFamily = "'Strait', sans-serif";
              headline2.style.fontSize = '12.5px';
              headline2.style.marginTop = '10px'; // Adjust the value as needed to lower the he
              // Show modal
              modal2.style.transition = 'opacity 0.65s';
              modal2.style.opacity = '1';
              modal2.style.width = '85%'; // Increased width to 80%
              modal2.style.height = '90%'; // Increased height to 80%

              // Position modal in the center of the screen
              modal2.style.top = '50%'; // Center vertically
              modal2.style.left = '50%'; // Center horizontally
              modal2.style.transform = 'translate(-50%, -50%)';
              modal2.style.display = 'block';

              // Close modal when clicking outside of it
              window.onclick = function (event) {
                if (event.target === modal2) {
                  modal2.style.display = "none";
                }
              };
            }
          }


        function backdropping(commando) {
          if (commando === "open") {
            let backdrop = document.getElementById('modal-backdrop');
            if (!backdrop) {
              backdrop = document.createElement('div');
              Object.assign(backdrop.style, {
                position: 'fixed',
                top: '0',
                left: '0',
                width: '100vw',
                height: '100vh',
                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                zIndex: '1',  // Backdrop z-index
                opacity: '0',
                transition: 'opacity 0.65s',
                overflow: 'hidden'
              });
              backdrop.id = 'modal-backdrop';
              document.body.appendChild(backdrop);

              const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
              document.body.style.paddingRight = `${scrollbarWidth}px`;
              document.body.style.overflow = 'hidden';

              requestAnimationFrame(() => {
                backdrop.style.opacity = '1';
              });
            }
          }

          if (commando === "close") {
            let backdrop = document.getElementById('modal-backdrop');
            if (backdrop) {
              backdrop.style.opacity = '0'; // Fade out
              backdrop.remove();
              document.body.style.paddingRight = '';
              document.body.style.overflow = ''; // Restore body scrolling
            }
          }
        }


          function initHelpModal2() {
            const modal = document.getElementById('modalarchive');
            const span = document.getElementById("close-archive"); 


             span.addEventListener("click", function () {
               
              modal.style.display = 'none';
            });}





      function dateStringToDate(dateString) {
        const parts = dateString.split('/');
        const day = parseInt(parts[0], 10);
        const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const monthIndex = months.findIndex(month => month === parts[1]);
        const year = parseInt(parts[2], 10);
        const date = new Date(year, monthIndex, day);
        return date;
        }



       function showModal4(puzzle1) {
        const modal = document.getElementById('modalarchive');
        const headline = document.getElementById('modal-headline-arc');
        const modal3dates = document.getElementById("nameElementarc");


        headline.textContent = "ARCHIVED GAMES";
        Object.assign(headline.style, {
                              fontFamily: "'Roboto', sans-serif",
                              fontSize: '16px',
                              fontWeight: 'bold',
                              color: '#333',
                              textTransform: 'uppercase',
                              textAlign: 'center',
                              marginBottom: '30px'
        });

        modal.style.display = 'block';
        modal.style.opacity = '0';
        modal.offsetHeight;
        Object.assign(modal.style, {
                            transition: 'opacity 0.65s',
                            opacity: '1',
                            width: '80%',
                            maxWidth: '290px',
                            height: '100%',
                            top: '50%',
                            left: '60%',
                            transform: 'translate(-50%, -50%)',
                            background: '#ffffff',
                            borderRadius: '8px',
                            padding: '10px',
                            boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)',
                            overflow: 'auto'
        });



         modal3dates.style.top = '40px';
         modal3dates.innerHTML = '';
         Object.assign(modal3dates.style, {
                            listStyleType: 'none',
                            marginRight: '1px',
                            padding: '0',
                            margin: '15px',
                            position: 'absolute',
                            left: '0'
         });

        const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        const startDate = new Date('2024-06-22');
        const today = new Date();
        const endDate = new Date(today);
        endDate.setDate(today.getDate());

          for (let date = endDate; date >= startDate; date.setDate(date.getDate() - 1)) {
            const listItem = document.createElement('li');
            const dateString = `${date.getDate()}/${months[date.getMonth()]}/${date.getFullYear()}`;

            limit2 = getTheDate(dateStringToDate(dateString));
        
            const scores = countWStatsForOrder(currentYugiGrid, limit2.toString(), "w")
            const scoresrep = countWStatsForOrder(currentYugiGrid, limit2.toString(), "r")
            const scoreserror = countWStatsForOrder(currentYugiGrid, limit2.toString(), "e")
            var zz = ""

            if (scores + scoreserror === 9) {
              zz = puzzleselection[limit2 - 1][0].ctry
            }

            var dateString2 = `[${limit2}] - ` + zz + " (" + (scores + scoresrep) + "/9)";
            listItem.classList.add('dateItem');
            if ((scores + scoresrep) > 0 && scores < 9) {
              listItem.style.backgroundColor = 'rgba(255, 165, 0, 0.2)'; 
              listItem.style.fontWeight = 'bold'; 

            }
            if ((scores + scoreserror) === 9 && scores < 9) {
              listItem.style.backgroundColor = 'rgb(169,193,178,0.2)'; 
              listItem.style.fontWeight = 'bold'; 
            }
            if (scores === 9) {
              listItem.style.backgroundColor = 'rgba(144, 238, 144, 0.5)'; // Lighter green background
              listItem.style.fontWeight = 'bold'; // Bold font weight

              if (scoresrep === 0) {
                dateString2 = dateString2 + " ⭐"
              }
            }
            listItem.textContent = dateString2

            listItem.addEventListener('click', function () {
              modal.style.display = 'none';
              limit = getTheDate(dateStringToDate(dateString));
              for (var i = 0; i < puzzleselection.length; i++) {
                if (limit - puzzleselection[i][0].order === 0) {
                  puzzle1 = puzzleselection[i];
                  break;
                }
              }
              currentYugiPuzzle = puzzle1[0].order;
              window.localStorage.setItem('currentYugiPuzzle', currentYugiPuzzle);
              window.localStorage.setItem('currentYugiArchive', "yes");
              setTimeout(function () {
                window.location.href = window.location.href;
              }, 800); 
            });

              let currentDateInET2 = getCurrentDateInTimeZone('America/New_York');
              let currentDateInETDate2 = new Date(currentDateInET2 + "T00:00:00Z");
              let limit00 = getTheDate(currentDateInETDate2) + 1;

              if (limit2 != 0 && limit2 < limit00) {
                modal3dates.appendChild(listItem);
              }
            }

            modal.addEventListener('click', function (event) {
              if (event.target === modal) {
                modal.style.display = 'none';
              }
            });
          }




  function getTheDate(a) {
    // Ensure `a` is a Date object
    if (!(a instanceof Date)) {
      a = new Date(a);
    }


    var b = new Date("2024-06-22");
    const _MS_PER_DAY = 1000 * 60 * 60 * 24;

    // Discard the time and time-zone information.
    const utc1 = Date.UTC(a.getFullYear(), a.getMonth(), a.getDate());
    const utc2 = Date.UTC(b.getFullYear(), b.getMonth(), b.getDate());

    const daysDifference = Math.round((utc1 - utc2) / _MS_PER_DAY) + 1;
    //console.log(daysDifference)
    return daysDifference;
  }

  function getCurrentDateInTimeZone(timeZone) {
    let options = {
      timeZone: timeZone,
      year: 'numeric',
      month: '2-digit',
      day: '2-digit',
      hour12: false
    };

    let formatter = new Intl.DateTimeFormat([], options);
    let parts = formatter.formatToParts(new Date());

    let dateObj = {};
    parts.forEach(({ type, value }) => {
      dateObj[type] = value;
    });

    return `${dateObj.year}-${dateObj.month}-${dateObj.day}`;
  }

  function todayPuzzle() {
    // Example usage for New York (Eastern Time)
    let currentDateInET = getCurrentDateInTimeZone('America/New_York');

    // Convert the string to a Date object
    let currentDateInETDate = new Date(currentDateInET + "T00:00:00Z");

    // Call getTheDate with the Date object
    let limit = getTheDate(currentDateInETDate);

    // let limit = getTheDate(currentDateInETDate)+17;


    for (var i = 0; i < puzzleselection.length; i++) {
      if (limit - puzzleselection[i][0].order === 0) {
        puzzle1 = puzzleselection[i];
        break;
      }
    }
    return puzzle1;
  }



  function solved() {
    const gridCellssolved = document.querySelectorAll('.grid-cellsolved, .grid-cellfod');;
    const gridCellsunsolved = document.querySelectorAll('.grid-cellunsolved');

    if (answers.length === 9 && !answers.includes("ERROR")) {

      const addFluorescentBorder = (cells, delay, ) => {
        setTimeout(() => {
          cells.forEach(cell => {
            cell.classList.add('fluorescent-border');
          });
        }, delay);
        setTimeout(() => {
          cells.forEach(cell => {
            cell.classList.remove('fluorescent-border');
            cell.classList.add('unfluorescent-border');
          });
        }, delay * 3);
      };

      //addFluorescentBorder(gridCellssolved, 600);


      if (gridCellssolved.length === 9) {

      } else {
        addFluorescentBorder(gridCellsunsolved, 200);
        addFluorescentBorder(gridCellssolved, 10);
      }
    }




    if (gridCellssolved.length + gridCellsunsolved.length === 9) {

      setTimeout(function () {
        showModal5();
      }, 500); // 1500 milliseconds = 1.5 seconds

    }


  }



        function showmodalCard(cardmax) {

          nameofcard = cardmax.couname
          imgofcard = cardmax.cardpic

          const modal = document.getElementById('modalq');
          const headline = document.getElementById('modal-headlineq');
          const btnmodal = document.getElementById('close-modalq');
          const removeElementIfPresent = (element) => {
            if (modal.contains(element)) {
              modal.removeChild(element);
            }
          };
          removeElementIfPresent
          // Function to close the modal
          function closeModalans() {

            setTimeout(() => {
              modal.style.display = "none";
              if (modal.contains(img)) {
                modal.removeChild(img);
              }
              if (modal.contains(ul)) {
                modal.removeChild(ul);
              }
              backdropping("close")

              modal.style.display = "none";
            }, 100); // Delay hiding the modal to ensure smooth transition completion
          }

          // Attach event listener to close button
          btnmodal.addEventListener("click", closeModalans);
          btnmodal.style.marginTop = '-10px'; // Adjust the value as needed to raise the button

          // Set modal headline text and styles
          headline.innerHTML = nameofcard;
          headline.style.fontFamily = "'Strait', sans-serif";
          headline.style.fontSize = '15px';
          headline.style.marginTop = '10px'; // Adjust the value as needed

          // Clear existing content in modal
          //modal.innerHTML = '';

          // Create and configure image element
          const img = document.createElement('img');
          img.src = imgofcard;
          img.alt = `${nameofcard} Flag`;
          img.style.maxWidth = '100%'; // Set maximum width to 100% of modal width
          img.style.height = 'auto'; // Maintain aspect ratio

          img.height = 49 * 1.05;
          img.width = 67.5 * 1.05;
          img.style.display = 'block'; // Ensures it behaves like a block-level element

          img.style.borderRadius = '7px'; // Add rounded corners, adjust the radius as needed
          img.style.border = '2px solid black'; // Add a 1px solid black border
          // Append image to modal
          img.style.cursor = "pointer";

          img.addEventListener('click', function () {
            window.open(imgofcard, '_blank');
          });
          modal.appendChild(img);




          const ul = document.createElement('ul');
          ul.style.listStyleType = 'none'; // Remove default list styles
          ul.style.padding = '0'; // Remove default padding to align to the left




          const lblank1000 = document.createElement('li');
          lblank1000.style.height = '8px';  // Adjust the height as needed
          ul.appendChild(lblank1000);

          const lyear1000 = document.createElement('li');
          lyear1000.innerHTML = '<strong>Effect Text:</strong> ';
          lyear1000.style.fontFamily = "'Strait', sans-serif";
          lyear1000.style.fontSize = '12px';

          if (cardmax.efct != "") {
            lyear1000.innerHTML = lyear1000.innerHTML + cardmax.efct

          }
          else {

            lyear1000.innerHTML = lyear1000.innerHTML + "-"
          }
          ul.appendChild(lyear1000);


          if (!cardmax.Items.includes("spells") && !cardmax.Items.includes("traps")) {
            const lblank3333 = document.createElement('li');
            lblank3333.style.height = '8px';  // Adjust the height as needed
            ul.appendChild(lblank3333);

            const lyear1333 = document.createElement('li');
            lyear1333.innerHTML = '<strong>Level: ★ </strong> ';
            lyear1333.style.fontFamily = "'Strait', sans-serif";
            lyear1333.style.fontSize = '12px';

            lyear1333.innerHTML = lyear1333.innerHTML + cardmax.lvel

            ul.appendChild(lyear1333);


            const lblankATDF = document.createElement('li');
            lblankATDF.style.height = '8px';  // Adjust the height as needed
            ul.appendChild(lblankATDF);

            const lyearATDF = document.createElement('li');
            lyearATDF.innerHTML = '<strong>ATK: ★ </strong> ';
            lyearATDF.style.fontFamily = "'Strait', sans-serif";
            lyearATDF.style.fontSize = '12px';

            lyearATDF.innerHTML = '<strong>ATK: </strong> ' + cardmax.atkval + '&nbsp;<strong>DEF: </strong> ' + cardmax.defval;

            ul.appendChild(lyearATDF);










          }


          const lblank = document.createElement('li');
          lblank.style.height = '8px';  // Adjust the height as needed
          ul.appendChild(lblank);

          const litems = document.createElement('li');
          litems.innerHTML = '<strong>Card Type:</strong> ';
          litems.style.fontFamily = "'Strait', sans-serif";
          litems.style.fontSize = '12px';


          var shapemax = [];

          if (cardmax.Items.includes("spells")) { shapemax.push("🟢 Spell") }
          if (cardmax.Items.includes("traps")) { shapemax.push("🟣Trap") }

          if (cardmax.Items.includes("contns")) { shapemax.push("♾️ Continuous") }

          if (cardmax.Items.includes("msPend")) { shapemax.push("🔶Pendulum Monster") }
          if (cardmax.Items.includes("msLink")) { shapemax.push("🔷 Link Monster") }
          if (cardmax.Items.includes("msRitu")) { shapemax.push("🟦 Ritual Monster") }
          if (cardmax.Items.includes("msSync")) { shapemax.push("⬜ Synchro Monster") }
          if (cardmax.Items.includes("msXYZs")) { shapemax.push("⬛ Xyz Monster") }
          if (cardmax.Items.includes("msFuse")) { shapemax.push("🟪 Fusion Monster") }
          if (cardmax.Items.includes("msEfct")) { shapemax.push("🟧 Effect Monster") }
          if (cardmax.Items.includes("msNorm")) { shapemax.push("🟨 Normal Monster") }
          if (cardmax.Items.includes("msTune")) { shapemax.push("💫 Tuner") }

          if (cardmax.Items.includes("msFlip")) { shapemax.push("↪️ Flip") }

          litems.innerHTML = litems.innerHTML + shapemax.join(', ')


          ul.appendChild(litems);




          if (!cardmax.Items.includes("spells") && !cardmax.Items.includes("traps")) {


            const lblank2 = document.createElement('li');
            lblank2.style.height = '8px';  // Adjust the height as needed
            ul.appendChild(lblank2);

            const litemstrue = document.createElement('li');
            litemstrue.innerHTML = '<strong>Monster Attributes:</strong> ';
            litemstrue.style.fontFamily = "'Strait', sans-serif";
            litemstrue.style.fontSize = '12px';


            var itemmax = [];
            if (cardmax.Items.includes("atLIGH")) { itemmax.push("🌕 LIGHT") }
            if (cardmax.Items.includes("atDARK")) { itemmax.push("🌑 DARK") }
            if (cardmax.Items.includes("atWIND")) { itemmax.push("☁️ WIND") }
            if (cardmax.Items.includes("atEART")) { itemmax.push("🪵 EARTH") }
            if (cardmax.Items.includes("atFIRE")) { itemmax.push("🔥 FIRE") }
            if (cardmax.Items.includes("atWATE")) { itemmax.push("💧 WATER") }
            if (cardmax.Items.includes("atDIVI")) { itemmax.push("☯️ DIVINE") }
            if (cardmax.Items.includes("tpAqua")) { itemmax.push("🌊 Aqua") }
            if (cardmax.Items.includes("tpBeas")) { itemmax.push("🐂 Beast") }
            if (cardmax.Items.includes("tpBewa")) { itemmax.push("🦧 Beast-Warrior") }
            if (cardmax.Items.includes("tpCybe")) { itemmax.push("💻 Cyberse") }
            if (cardmax.Items.includes("tpDrag")) { itemmax.push("🐉 Dragon") }
            if (cardmax.Items.includes("tpDino")) { itemmax.push("🦕 Dinosaur") }
            if (cardmax.Items.includes("tpFair")) { itemmax.push("🧚 Fairy") }
            if (cardmax.Items.includes("tpFish")) { itemmax.push("🐟 Fish") }
            if (cardmax.Items.includes("tpFien")) { itemmax.push("🎃 Fiend") }
            if (cardmax.Items.includes("tpIllu")) { itemmax.push("🪞 Illusion") }
            if (cardmax.Items.includes("tpInse")) { itemmax.push("🐜 Insect") }
            if (cardmax.Items.includes("tpMach")) { itemmax.push("🤖 Machine") }
            if (cardmax.Items.includes("tpPsyc")) { itemmax.push("🔮 Psychic") }
            if (cardmax.Items.includes("tpPlan")) { itemmax.push("🌱 Plant") }
            if (cardmax.Items.includes("tpPyro")) { itemmax.push("🌋 Pyro") }
            if (cardmax.Items.includes("tpRept")) { itemmax.push("🦎 Reptile") }
            if (cardmax.Items.includes("tpRock")) { itemmax.push("🗿 Rock") }
            if (cardmax.Items.includes("tpSeap")) { itemmax.push("🦑 Sea Serpent") }
            if (cardmax.Items.includes("tpSpel")) { itemmax.push("🪄 Spellcaster") }
            if (cardmax.Items.includes("tpThun")) { itemmax.push("⚡ Thunder") }
            if (cardmax.Items.includes("tpWarr")) { itemmax.push("🗡️ Warrior") }
            if (cardmax.Items.includes("tpWing")) { itemmax.push("🐦‍🔥 Winged Beast") }
            if (cardmax.Items.includes("tpWyrm")) { itemmax.push("🐉 Wyrm") }
            if (cardmax.Items.includes("tpZomb")) { itemmax.push("🧟 Zombie") }

            litemstrue.innerHTML = litemstrue.innerHTML + itemmax.join(', ')


            ul.appendChild(litemstrue);

          }





          const lblank0 = document.createElement('li');
          lblank0.style.height = '8px';  // Adjust the height as needed
          //   ul.appendChild(lblank0);

          const lmay = document.createElement('li');
          lmay.innerHTML = '<strong>Effects:</strong> ';
          lmay.style.fontFamily = "'Strait', sans-serif";
          lmay.style.fontSize = '12px';


          var mayormax = [];
          if (cardmax.Items.includes("efAdds")) { mayormax.push("🎁 Add") }
          if (cardmax.Items.includes("efBani")) { mayormax.push("🚀 Banish") }
          if (cardmax.Items.includes("efCant")) { mayormax.push("🕊 Cannot be destroyed") }
          if (cardmax.Items.includes("efCter")) { mayormax.push("🀄️ Counter") }
          if (cardmax.Items.includes("efNoss")) { mayormax.push("⛔️ Cannot be Normal Summoned") }
          if (cardmax.Items.includes("efCoin")) { mayormax.push("🪙 Coin") }
          if (cardmax.Items.includes("efCtrl")) { mayormax.push("🎮 Control") }
          if (cardmax.Items.includes("efDamg")) { mayormax.push("☄️ Damage") }
          if (cardmax.Items.includes("efDest")) { mayormax.push("🌀 Destroy") }
          if (cardmax.Items.includes("efDice")) { mayormax.push("🎲 Dice") }
          if (cardmax.Items.includes("efDisc")) { mayormax.push("👐🏼 Discard") }
          if (cardmax.Items.includes("efDraw")) { mayormax.push("➕ Draw") }
          if (cardmax.Items.includes("efGrav")) { mayormax.push("🪦 Graveyard") }
          if (cardmax.Items.includes("efHand")) { mayormax.push("🖐🏼 From your hand") }
          if (cardmax.Items.includes("efNega")) { mayormax.push("🚫 Negate") }
          if (cardmax.Items.includes("efSend")) { mayormax.push("📨 Send") }
          if (cardmax.Items.includes("efPays")) { mayormax.push("📉 Pay") }
          if (cardmax.Items.includes("efToke")) { mayormax.push("🐏 Token") }
          if (cardmax.Items.includes("efSpec")) { mayormax.push("🎊 Special Summon") }
          if (cardmax.Items.includes("efTarg")) { mayormax.push("🎯 Target") }
          if (cardmax.Items.includes("efTrib")) { mayormax.push("♙ Tribute") }
          if (cardmax.Items.includes("efOnce")) { mayormax.push("1️⃣ Once") }




          if (mayormax[0] === undefined) {
            mayormax.push("-")
          }
          lmay.innerHTML = lmay.innerHTML + mayormax.join(', ')
          //      ul.appendChild(lmay);





          const lanim = document.createElement('li');
          lanim.innerHTML = '<strong>Played by:</strong> ';
          lanim.style.fontFamily = "'Strait', sans-serif";
          lanim.style.fontSize = '12px';


          var animax = [];
          if (cardmax.Items.includes("anYugi")) { animax.push("Yugi") }
          if (cardmax.Items.includes("anJoey")) { animax.push("Joey") }
          if (cardmax.Items.includes("anSeto")) { animax.push("Kaiba") }


          if (animax[0] !== undefined) {
            lanim.innerHTML = lanim.innerHTML + animax.join(', ')
            const lblank7 = document.createElement('li');
            lblank7.style.height = '8px';  // Adjust the height as needed
            ul.appendChild(lblank7);

            ul.appendChild(lanim);

          }



          // Append <ul> with color list to modal
          modal.appendChild(ul);

          setTimeout(() => {
            backdropping("open");
          }, 5); // Adjust the time (in milliseconds) as needed



          modal.style.display = 'block';
          modal.style.position = 'fixed';
          modal.style.zIndex = '1001';
          modal.style.background = 'white';
          modal.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)';
          modal.style.width = '70%';
          modal.style.height = '60%';
          modal.style.top = '50%';
          modal.style.left = '50%';
          modal.style.transform = 'translate(-50%, -50%)';
          modal.style.overflowY = 'scroll';
          modal.style.opacity = '0'; // Start with 0 opacity
          modal.style.transition = 'opacity 1s';

          // Trigger reflow to ensure the transition works
          modal.offsetHeight; // This forces a reflow

          // Set the opacity to 1 after a short delay
          setTimeout(() => {
            modal.style.opacity = '1';
          }, 10); // Short delay to allow the initial opacity to take effect
        
          // Create a style element for the scrollbar
          const style = document.createElement('style');
          style.innerHTML = `
  #modalq::-webkit-scrollbar {
      width: 8px; /* Width of the scrollbar */
  }
  #modalq::-webkit-scrollbar-thumb {
      background: #888; /* Color of the scrollbar */
      border-radius: 10px; /* Rounded corners */
  }
  #modalq::-webkit-scrollbar-thumb:hover {
      background: #555; /* Darker color on hover */
  }
  #modalq::-webkit-scrollbar-track {
      background: #f1f1f1; /* Color of the scrollbar track */
      border-radius: 10px; /* Rounded corners */
  }
`;
          document.head.appendChild(style);
          modal.style.maxWidth = '450px'; // Width of the modal
          modal.style.maxHeight = '800px'; // Width of the modal
          document.body.appendChild(modal);

          // Trigger reflow to apply transition
          modal.offsetHeight;

          // Fade in the modal
          modal.style.opacity = '1';

        }

  theflags = []

  function cfs(statingrid) {

    if (statingrid.status === 'w') {
      if (statingrid.name === puzzleselection[Number(puzzleYugiGrid.order - 1)][0].ctry) {
        // if (statingrid.name = puzzleselection[Number(puzzleFlagGrid.order - 1)][0].ctry){
        return "🟨"
      }
      var flagtick = theflags.filter(flag => flag.countr === statingrid.name)[0];


      return flagtick ? flagtick.emj : '🟫';
      //return "🟨"
    }
    return "❌"

  }

  function cfs2(statingrid) {

    if (statingrid.status === 'w') {

      if (statingrid.name === puzzleselection[Number(puzzleYugiGrid.order - 1)][0].ctry) {
        return "🟨"
      }
      //const flagtick = theflags.filter(flag => flag.countr === statingrid.name)[0];
      //  return flagtick ? flagtick.emj : '🏳️';
      return "🟫"
    }
    return "❌ "

  }
  function solutionshare() {

    fx = [cfs(puzzleYugiGrid.row1col1), cfs(puzzleYugiGrid.row1col2), cfs(puzzleYugiGrid.row1col3)]
    fy = [cfs(puzzleYugiGrid.row2col1), cfs(puzzleYugiGrid.row2col2), cfs(puzzleYugiGrid.row2col3)]
    fz = [cfs(puzzleYugiGrid.row3col1), cfs(puzzleYugiGrid.row3col2), cfs(puzzleYugiGrid.row3col3)]

    return [fx, fy, fz]

  }

  function solutionshare2() {
    fx = [cfs2(puzzleYugiGrid.row1col1), cfs2(puzzleYugiGrid.row1col2), cfs2(puzzleYugiGrid.row1col3)]
    fy = [cfs2(puzzleYugiGrid.row2col1), cfs2(puzzleYugiGrid.row2col2), cfs2(puzzleYugiGrid.row2col3)]
    fz = [cfs2(puzzleYugiGrid.row3col1), cfs2(puzzleYugiGrid.row3col2), cfs2(puzzleYugiGrid.row3col3)]

    return [fx, fy, fz]

  }


  function showModal5() {
    const modal = document.getElementById('modalsolved');
    const headline = document.getElementById('modal-solved-arc');
    const modal3dates = document.getElementById("nameElementarc");
    const spansolved = document.getElementById("close-solved");  // Get the <span> element that closes the modal




















    // Clear existing content except for the close button
    function clearModalContent() {
      modal.querySelectorAll('span:not(#close-solved), a').forEach(element => {
        element.textContent = '';
      });
      modal.querySelectorAll('img').forEach(element => {
        element.remove();
      });
      // Remove all <br> elements to avoid large blank spaces
      modal.querySelectorAll('br').forEach(element => {
        element.remove();
      });
      modal.querySelectorAll('button').forEach(element => {
        element.remove();
      });
    }

    // Clear existing content before rendering new content
    clearModalContent();
    fshare = solutionshare();
    fshare2 = solutionshare2();

    headline.textContent = "RESULTS";
    headline.style.fontFamily = "'Strait', sans-serif";
    headline.style.fontSize = '16px'; // Increase font size for better emphasis
    headline.style.fontWeight = 'bold'; // Add bold font weight for prominence
    headline.style.color = '#333'; // Set text color to a darker shade for better contrast
    headline.style.textTransform = 'uppercase'; // Transform text to uppercase for a more formal appearance
    headline.style.textAlign = 'center'; // Center-align the text for better visual balance
    headline.style.marginBottom = '12px'; // Add some bottom margin for spacing

    var ulElement = document.getElementById("totalSolved");
    ulElement.style.listStyleType = "none";

    supertext = [
      { text: fshare[0][0] + fshare[0][1] + fshare[0][2], className: "format1" },
      { text: fshare[1][0] + fshare[1][1] + fshare[1][2], className: "format1" },
      { text: fshare[2][0] + fshare[2][1] + fshare[2][2], className: "format1" }
    ];

    var itemsToAdd = [
      { text: '', className: "" },
      { text: "CARD OF THE DAY", className: "format1" },
      {
        text: "",
        className: "format1",
        image: cards.find(card => card.couname === puzzleselection[Number(puzzleYugiGrid.order - 1)][0].ctry).cardpic // Replace with the actual image URL
      },
      {
        text: puzzleselection[Number(puzzleYugiGrid.order - 1)][0].ctry,
        className: "format1",
      },
      { text: "SCORE: " + document.querySelectorAll('.grid-cellsolved, .grid-cellfod').length + "/" + 9 + "  ", className: "format1" },

      { text: fshare[0][0] + " " + fshare[0][1] + " " + fshare[0][2], className: "format1" },
      { text: fshare[1][0] + " " + fshare[1][1] + " " + fshare[1][2], className: "format1" },
      { text: fshare[2][0] + " " + fshare[2][1] + " " + fshare[2][2], className: "format1" },
      { text: "We have a subreddit now!", className: "format1" },
      { text: "(r/Flagdoku)", className: "format1", href: 'https://www.reddit.com/r/Flagdoku/' },
      { text: "", className: "" },
      { text: "Follow us on Twitter/X", className: "format1" },
      { text: "(@Flagdoku)", className: "format1", href: 'https://x.com/Flagdoku' },
      { text: "", className: "" },
      { text: "Check out our other game", className: "format1" },
      { text: "   ⚽Futdoku", className: "format1", href: 'https://futdoku.com' },
    ];

    function renderItems() {
      var container = document.getElementById('modalsolved');

      if (!container) {
        console.error('Container element with id "modalsolved" not found');
        return;
      }

      itemsToAdd.forEach(function (item, index) {
        // Create and style the button before "Follow us on Twitter/X"


        if (item.text.includes("SCORE")) {
          var button = document.createElement('button');
          button.textContent = 'EXPAND';
          button.id = 'clickMe2Button';
          button.style.marginRight = '2px'; // Add some space before the edge
          button.classList.add('coolButton3'); // Add a class for styling
          button.style.marginLeft = '12px';

          container.appendChild(button);
          var lineBreak = document.createElement('br'); // Create a <br> element
          container.appendChild(lineBreak); // Append the <br> element to the container
          var lineBreak = document.createElement('br'); // Create a <br> element
          container.appendChild(lineBreak); // Append the <br> element to the container


          button.addEventListener('click', function () {
            showmodalCard(cards.find(card => card.couname === puzzleselection[Number(puzzleYugiGrid.order - 1)][0].ctry))
          });

        }

        if (item.text === "We have a subreddit now!") {




          var button = document.createElement('button');
          button.textContent = 'CLICK TO SHARE';
          button.id = 'clickMe2Button';
          button.style.marginRight = '2px'; // Add some space before the edge
          button.classList.add('coolButton2'); // Add a class for styling
          button.style.marginLeft = '12px';
          container.appendChild(button);


          // Add event listener to handle click event
          button.addEventListener('click', function () {
            // Add 'Flagdoku' as the first row
            fshare.unshift(['Flagdoku ' + puzzleYugiGrid.order + " " + document.querySelectorAll('.grid-cellsolved, .grid-cellfod').length + "/9"]);

            // Join the formatted text with newline characters for each row
            var supertext = fshare.map(function (row) {
              return row.join(' ');
            }).join('\n');

            // Create a temporary textarea element to facilitate copying
            var textarea = document.createElement('textarea');
            textarea.value = supertext;
            textarea.style.position = 'fixed'; // Ensure it's not visible
            document.body.appendChild(textarea);

            // Select the text inside the textarea
            textarea.select();


            // Execute the copy command
            var successful = document.execCommand('copy');
            var message = successful ? 'Copied to clipboard!' : 'Unable to copy';


            // Show modal message
            alert(message); // This shows an alert dialog
            document.body.removeChild(textarea);

            // Remove the added row to keep fshare unchanged
            fshare.shift();
          });






          var button22 = document.createElement('button');
          button22.textContent = 'SPOILER FREE';
          button22.id = 'clickMe2Button';
          button22.style.marginRight = '2px'; // Add some space before the edge
          button22.classList.add('coolButton2'); // Add a class for styling
          button22.style.marginLeft = '12px';
          container.appendChild(button22);
          container.appendChild(document.createElement('br'));
          container.appendChild(document.createElement('br'));

          // Add event listener to handle click event
          button22.addEventListener('click', function () {
            // Add 'Flagdoku' as the first row
            fshare2.unshift(['Flagdoku ' + puzzleYugiGrid.order + " " + document.querySelectorAll('.grid-cellsolved, .grid-cellfod').length + "/9"]);

            // Join the formatted text with newline characters for each row
            var supertext = fshare2.map(function (row) {
              return row.join(' ');
            }).join('\n');

            // Create a temporary textarea element to facilitate copying
            var textarea = document.createElement('textarea');
            textarea.value = supertext;
            textarea.style.position = 'fixed'; // Ensure it's not visible
            document.body.appendChild(textarea);

            // Select the text inside the textarea
            textarea.select();


            // Execute the copy command
            var successful = document.execCommand('copy');
            var message = successful ? 'Copied to clipboard!' : 'Unable to copy';


            // Show modal message
            alert(message); // This shows an alert dialog
            document.body.removeChild(textarea);

            // Remove the added row to keep fshare unchanged
            fshare2.shift();
          });
















        }
        var element = document.createElement('span');
        element.textContent = item.text;
        element.className = item.className;
        element.style.marginLeft = '15px'; // Adjust the margin-left here

        if (item.href) {
          var link = document.createElement('a');
          link.href = item.href;
          link.appendChild(element);
          container.appendChild(link);
        } else {
          container.appendChild(element);
        }
        if (item.text.includes("r/Flagdoku")) {
          link.style.color = 'darkorange';
        }
        // Check if the item has an image property and create an img element
        if (item.image) {
          var img = document.createElement('img');
          img.src = item.image;
          img.alt = "Flag";
          img.style.marginLeft = '0px'; // Add some spacing if needed
          img.style.height = '70px'; // Adjust the height as needed
          img.style.border = '1px solid black'; // Add a black border
          img.style.borderRadius = '2px'; // Add rounded corners, adjust the radius as needed
          container.appendChild(img);
        }

        // Add line break after each item, except for the last one
        if (index < itemsToAdd.length - 1) {
          container.appendChild(document.createElement('br'));
        }
      });
    }

    // Loop through the array and create list items for each text
    renderItems();
    function closeModal() {
      clearModalContent();

      setTimeout(() => {
        modal.style.display = "none";
      }, 100); // Delay hiding the modal to ensure smooth transition completion
    }

    spansolved.addEventListener("click", closeModal);

    modal.style.opacity = '0';
    modal.style.display = 'block';
    modal.offsetHeight;
    modal.style.transition = 'opacity 0.65s';
    modal.style.opacity = '1';
    modal.style.width = '100%'; // Adjusted width for better visibility
    modal.style.maxWidth = '600px'; // Added maximum width to prevent it from getting too wide
    modal.style.height = '140%'; // Adjusted height to auto
    modal.style.top = '70%';
    modal.style.left = '50%';
    modal.style.transform = 'translate(-50%, -50%)'; // Center the modal horizontally and vertically
    modal.style.background = '#ffffff'; // Set background color to white
    modal.style.borderRadius = '8px'; // Added border radius for a softer appearance
    modal.style.padding = '10px'; // Added padding for better spacing
    modal.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.2)'; // Added subtle shadow for depth
    modal.style.overflow = 'auto'; // Add scroll bar when content overflows
  }



}

);









