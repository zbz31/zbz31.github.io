

const url = 'https://raw.githubusercontent.com/zbz31/zbz31.github.io/refs/heads/main/ygjap5.txt';

async function fetchCards() {
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error('Network response was not ok');
    const data = await response.text();
    const cards = JSON.parse(data); // Parse the fetched data
    cards.sort((a, b) => parseInt(b.rank) - parseInt(a.rank)); // Sort the cards by rank
    //cards.sort((a, b) => parseInt(a.name) - parseInt(b.name)); // Sort the cards by name
    return cards;
  } catch (error) {
    console.error('Fetch error:', error);
    return [];
  }
}



document.addEventListener("DOMContentLoaded", async () => {


    var allcards = await fetchCards(); // Wait for cards to be fetched
    searchc = []
    orderclassic = ""
    let currentFlagGrid = []

    initLocalStorage();

    let newCell;
    let newCell2

    indice2();

    function padAtkVal(value) {
      let str = String(value); // Convert to string
      // Pad with leading zeros to ensure a consistent length for comparison
      str = str.padStart(15, '0'); // Adjust 15 as needed
      return str;
    }

    function initLocalStorage() {
      const storedcurrentFlagPuzzle = window.localStorage.getItem('currentFlagPuzzle');

      const storedcurrentFlagGrid = window.localStorage.getItem('current4FlagGrid');
      if (!storedcurrentFlagGrid) {
        window.localStorage.setItem('current4FlagGrid', currentFlagGrid);
      } else {
        currentFlagGrid = JSON.parse(storedcurrentFlagGrid);
      }


      if (!storedcurrentFlagGrid) {
        window.localStorage.setItem('current4FlagGrid', currentFlagGrid);
      } else {
        currentFlagGrid = JSON.parse(storedcurrentFlagGrid);
      }
      const storedFlagArchive = window.localStorage.getItem('currentFlagArchive');
      if (storedFlagArchive === "no") {


      }
      if (!storedFlagArchive) {
        window.localStorage.setItem('currentFlagArchive', "no");
      }

    }

    function showModalExtra(name, flags) {


      const modal = document.getElementById('modal2');
      const headline = document.getElementById('modal-headline2');
      const btnmodal = document.getElementById('close-modal2');

      // Create a function to clear the modal content
      function clearModal() {
        const linesContainer = modal.querySelector('div');
        if (linesContainer) {
          modal.removeChild(linesContainer);
        }
      }

      function closeModalans() {
        clearModal(); // Clear the modal content

        modal.style.display = "none";

      }

      btnmodal.addEventListener("click", closeModalans);
      btnmodal.style.marginTop = '-10px'; // Adjust the value as needed to raise the button

      headline.textContent = name;
      headline.style.fontFamily = "'Strait', sans-serif";
      headline.style.fontSize = '16.5px';
      headline.style.marginTop = '5px'; // Adjust the value as needed to lower the headline

      modal.style.opacity = '0';
      modal.style.display = 'block';
      modal.offsetHeight; // Trigger a reflow to ensure the transition works
      modal.style.transition = 'opacity 0.65s';
      modal.style.opacity = '1';

      // Set adaptive width and height
      modal.style.width = '70vw'; // 70% of the viewport width
      modal.style.height = '70vh'; // 70% of the viewport height

      // Position the modal closer to the top
      modal.style.position = 'fixed';
      modal.style.top = '7%'; // Adjust this value to move the modal closer to the top
      modal.style.left = '50%';
      modal.style.transform = 'translate(-50%, 0)'; // Vertical position is set by 'top'

     const characters = [
  
          'Name â†“',
          'Name â†‘',

          'âš”ï¸ ATK â†“', 
          'âš”ï¸ ATK â†‘',

          'ðŸ›¡ï¸ DEF â†“',
          'ðŸ›¡ï¸ DEF â†‘',

          'â˜… Level/Rank â†“',
          'â˜… Level/Rank â†‘',
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        characters.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }

          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
          line.textContent = color;

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect

      


            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            line.style.backgroundColor = 'lightgreen'; // Change to the second color
            line.style.transform = 'scale(0.98)';
            setTimeout(() => {
              line.style.transform = 'scale(1)';
              line.style.backgroundColor = 'white'; // Revert back to white
            }, 300); // Change the number (2000) to the number of milliseconds you want


         



              //here is where it starts
              const ul = document.createElement('ul');
              ul.style.listStyleType = 'none';
              ul.style.padding = '0';
              ul.style.margin = '0';




              const li2 = document.createElement('li');

              // Set the text content for the list item
              li2.textContent = flags.length + " results";

              // Check for the number of results
              if (flags.length > 249) {
                li2.textContent = "250+ results";
              }

              // Style the list item
              li2.style.display = 'flex';
              li2.style.alignItems = 'center';
              li2.style.marginBottom = '10px'; // Optional
              li2.style.fontWeight = 'bold'; // Make the text bold



              const btnback7 = document.createElement('button');
              btnback7.textContent = "Ordered by " + line.textContent; // Set button text
              btnback7.style.marginLeft = 'auto'; // Push the button to the right
              // Optionally, add styles to the button
              btnback7.style.padding = '4px 8px';
              btnback7.style.cursor = 'pointer';

              btnback7.style.backgroundColor = 'lightgray'; // Green background
              btnback7.style.color = 'black'; // White text
              btnback7.style.border = 'none'; // No border

              btnback7.style.fontSize = '10px'; // Font size
              btnback7.style.fontFamily = "'Strait', sans-serif";
              btnback7.style.cursor = 'pointer'; // Pointer cursor
              btnback7.style.borderRadius = '4px'; // Rounded corners


              // Append the button to li2
              li2.appendChild(btnback7);
              btnback7.addEventListener('click', () => {
                showModalExtra("Order By", flags);
      
              });

              // Append li2 to the unordered list
              ul.appendChild(li2);


              

              flags.sort((a, b) => {



                

                if (line.textContent === "Name â†“") {

                  return a.couname.localeCompare(b.couname);
                }

                if (line.textContent === "Name â†‘") {

                  return b.couname.localeCompare(a.couname);
                }
                if (line.textContent === "âš”ï¸ ATK â†‘") {

                  return (("aaaaa" + padAtkVal(a.atkval)).localeCompare("aaaaa" + padAtkVal(b.atkval)));
                }
                if (line.textContent === "âš”ï¸ ATK â†“") {
                  return (("aaaaa" + padAtkVal(b.atkval)).localeCompare("aaaaa" + padAtkVal(a.atkval)));

             
                }
                if (line.textContent === "ðŸ›¡ï¸ DEF â†‘") {

                  return (("aaaaa" + padAtkVal(a.defval)).localeCompare("aaaaa" + padAtkVal(b.defval)));
                }
                if (line.textContent === "ðŸ›¡ï¸ DEF â†“") {

                  return (("aaaaa" + padAtkVal(b.defval)).localeCompare("aaaaa" + padAtkVal(a.defval)));
                }
                if (line.textContent === "â˜… Level/Rank â†“") {

                  return (("aaaaa" + padAtkVal(a.lvel)).localeCompare("aaaaa" + padAtkVal(b.lvel)));
                }
                if (line.textContent === "â˜… Level/Rank â†‘") {

                  return (("aaaaa" + padAtkVal(b.lvel)).localeCompare("aaaaa" + padAtkVal(a.lvel)));
                }


                return 0;
              }).slice(0, 250).forEach(flag => {
                const li = document.createElement('li');
                li.style.display = 'flex';
                li.style.alignItems = 'center';
                li.style.marginBottom = '10px'; // Optional: add some space between list items

                // Create an anchor element for the hyperlink
                const a = document.createElement('a');
                a.href = flag.cardlink;  // Set the URL from flags.cardlink
                a.style.textDecoration = 'none';  // Remove underline from text (optional)
                a.style.color = 'inherit';  // Keep the original text color
                a.style.display = 'flex';  // Make anchor a flex container
                a.style.alignItems = 'center';  // Center items vertically in the anchor

                // Create an image element for the flag
                const img = document.createElement('img');
                img.src = flag.cardpic;
                img.alt = `${flag.couname} Flag`;
                img.style.width = '20px'; // Adjust the width as needed
                img.style.height = 'auto'; // Adjust the height as needed
                img.style.marginRight = '10px'; // Space between the image and text
                img.style.borderRadius = '10%'; // Rounded corners
                img.style.border = '1px solid #000'; // Add a border (adjust color and thickness as needed)

                // Set image to be clickable and trigger modal
                img.style.cursor = "pointer";
                img.addEventListener('click', function (e) {

                  e.preventDefault();  // Prevent the link from being followed when clicking the image
                  showmodalCard(flag);
                });

                // Append the image to the anchor
                a.appendChild(img);

                // Set the text content of the anchor
                const textNode = document.createTextNode(flag.couname);
                const atkSpan = document.createElement('span');
                atkSpan.style.marginLeft = 'auto'; // Push ATK text to the right
                atkSpan.textContent = "(â˜†" + `${flag.lvel}` + ") " + `${flag.atkval}` + " - " + `${flag.defval}`;
                atkSpan.style.fontSize = '0.7em'; // Set smaller font size
                a.appendChild(textNode);
                li.appendChild(a);


                if (flag.atkval !== undefined && flag.defval !== undefined) {
                  li.appendChild(atkSpan); // Append the ATK text after the anchor
                  // Append the list item to the unordered list
                }
             

                // Append the list item to the unordered list
                if (!(line.textContent.includes("ATK") && flag.atkval === undefined) && !(line.textContent.includes("DEF") && flag.defval === undefined) && !(line.textContent.includes("Level/Rank") && flag.lvel === undefined)) {
                  ul.appendChild(li);
                }
              });

              newCell2.textContent = "";
              newCell2.appendChild(ul);


            flags.sort((a, b) => {

              if (line.textContent === "Name â†“") {

                return a.couname.localeCompare(b.couname);
              }

              if (line.textContent === "Name â†‘") {

                return b.couname.localeCompare(a.couname);
              }
              if (line.textContent === "âš”ï¸ ATK â†‘") {

                return (("aaaaa" + padAtkVal(a.atkval)).localeCompare("aaaaa" + padAtkVal(b.atkval)));
              }
              if (line.textContent === "âš”ï¸ ATK â†“") {
                return (("aaaaa" + padAtkVal(b.atkval)).localeCompare("aaaaa" + padAtkVal(a.atkval)));


              }
              if (line.textContent === "ðŸ›¡ï¸ DEF â†‘") {

                return (("aaaaa" + padAtkVal(a.defval)).localeCompare("aaaaa" + padAtkVal(b.defval)));
              }
              if (line.textContent === "ðŸ›¡ï¸ DEF â†“") {

                return (("aaaaa" + padAtkVal(b.defval)).localeCompare("aaaaa" + padAtkVal(a.defval)));
              }

              if (line.textContent === "â˜… Level/Rank â†“") {

                return (("aaaaa" + padAtkVal(a.lvel)).localeCompare("aaaaa" + padAtkVal(b.lvel)));
              }
              if (line.textContent === "â˜… Level/Rank â†‘") {

                return (("aaaaa" + padAtkVal(b.lvel)).localeCompare("aaaaa" + padAtkVal(a.lvel)));
              }


              return 0;
            }).slice(0, 250).forEach(flag => {
              const li = document.createElement('li');
              li.style.display = 'flex';
              li.style.alignItems = 'center';
              li.style.marginBottom = '10px'; // Optional: add some space between list items

              // Create an anchor element for the hyperlink
              const a = document.createElement('a');
              a.href = flag.cardlink;  // Set the URL from flags.cardlink
              a.style.textDecoration = 'none';  // Remove underline from text (optional)
              a.style.color = 'inherit';  // Keep the original text color
              a.style.display = 'flex';  // Make anchor a flex container
              a.style.alignItems = 'center';  // Center items vertically in the anchor

              // Create an image element for the flag
              const img = document.createElement('img');
              img.src = flag.cardpic;
              img.alt = `${flag.couname} Flag`;
              img.style.width = '20px'; // Adjust the width as needed
              img.style.height = 'auto'; // Adjust the height as needed
              img.style.marginRight = '10px'; // Space between the image and text
              img.style.borderRadius = '10%'; // Rounded corners
              img.style.border = '1px solid #000'; // Add a border (adjust color and thickness as needed)

              // Set image to be clickable and trigger modal
              img.style.cursor = "pointer";
              img.addEventListener('click', function (e) {

                e.preventDefault();  // Prevent the link from being followed when clicking the image
                showmodalCard(flag);
              });

              // Append the image to the anchor
              a.appendChild(img);

              // Set the text content of the anchor
              a.appendChild(document.createTextNode(flag.couname));



              // Append the anchor to the list item
              li.appendChild(a);

              // Append the list item to the unordered list
              if ((line.textContent.includes("ATK") && flag.atkval === undefined) || (line.textContent.includes("DEF") && flag.defval === undefined) || (line.textContent.includes("Level/Rank") && flag.defval === undefined)) {
                ul.appendChild(li);
              }
            });

            newCell2.appendChild(ul);

            
            closeModalans(); 
          });
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      








      // Close modal when clicking outside the textbox
      modal.addEventListener('click', function (event) {
        if (event.target === modal) {
          closeModalans(); // Use closeModalans to clear the modal content
        }
      });
    }











    function showModal(name) {


      const modal = document.getElementById('modal2');
      const headline = document.getElementById('modal-headline2');
      const btnmodal = document.getElementById('close-modal2');

      // Create a function to clear the modal content
      function clearModal() {
        const linesContainer = modal.querySelector('div');
        if (linesContainer) {
          modal.removeChild(linesContainer);
        }
      }

      function closeModalans() {
        clearModal(); // Clear the modal content

        modal.style.display = "none";

      }

      btnmodal.addEventListener("click", closeModalans);
      btnmodal.style.marginTop = '-10px'; // Adjust the value as needed to raise the button

      headline.textContent = name;
      headline.style.fontFamily = "'Strait', sans-serif";
      headline.style.fontSize = '16.5px';
      headline.style.marginTop = '5px'; // Adjust the value as needed to lower the headline

      modal.style.opacity = '0';
      modal.style.display = 'block';
      modal.offsetHeight; // Trigger a reflow to ensure the transition works
      modal.style.transition = 'opacity 0.65s';
      modal.style.opacity = '1';

      // Set adaptive width and height
      modal.style.width = '70vw'; // 70% of the viewport width
      modal.style.height = '70vh'; // 70% of the viewport height

      // Position the modal closer to the top
      modal.style.position = 'fixed';
      modal.style.top = '7%'; // Adjust this value to move the modal closer to the top
      modal.style.left = '50%';
      modal.style.transform = 'translate(-50%, 0)'; // Vertical position is set by 'top'

      // Create a container for the colored lines



      if (name.includes("Played By")) {
        const colors = [
          ' ',
          'Duel Monsters',
          'ðŸŸ¦ Yugi Muto',
          'ðŸŸ© <strong>Joey Wheeler</strong> / Katsuya Jonouchi',
          'ðŸŸ© Seto Kaiba',

          'ðŸŸ« Mai Valentine',
          'ðŸŸ« Mako Tsunami',
          'ðŸŸ« Rex Raptor / Dinosaur Ryuzaki',

          'ðŸŸ« Weevil Underwood / Insector Haga',
          'ðŸŸ¥ Maximillion Pegasus / Pegasus J. Crawford',
          'ðŸŸ¥ Marik Ishtar / Yami Marik',
          'ðŸŸ¥ Ryo Bakura',

          '  ',
          'GX',
          'ðŸŸ¦ Jaden Yuki',
          'ðŸŸ© Chazz Princeton',
          'ðŸŸ© Zane Truesdale',
          'ðŸŸ« Alexis Rhodes',
          'ðŸŸ« Bastion Misawa',
          'ðŸŸ¥ Yubel',
          'ðŸŸ¥ Nightshroud',
          'ðŸŸ¥ Sartorius',
          '  ',
          '5Ds',
          'ðŸŸ¦ Yusei Fudo',
          'ðŸŸ© Jack Atlas',
          'ðŸŸ© Crow Hogan',
          'ðŸŸ« Akiza Izinski',
          'ðŸŸ« Kalin Kessler',
          '  ',

          'Zexal',
          'ðŸŸ¦ Yuma Tsukumo',
          'ðŸŸ© Jack Atlas',
          'ðŸŸ© Crow Hogan',
          'ðŸŸ« Akiza Izinski',
          'ðŸŸ« Kalin Kessler',
          'ðŸŸ¥ Ryo Bakura',
          '  ',

          'VRAINS',
          'ðŸŸ¦ Yusaku - Playmaker',
          'ðŸŸ© Jack Atlas',
          'ðŸŸ© Crow Hogan',
          'ðŸŸ¥ George Gore',

        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        colors.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'space-between'; // Space between text and buttons
          line.style.height = '12px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          if (color !== ' ' && color !== 'Main Color' && color !== '  ' && color !== 'GX' && color !== '5Ds' && color !== 'Zexal' && color !== 'Arc-V' && color !== 'VRAINS' && color !== 'Duel Monsters') {
            line.style.height = '30px';
            line.style.backgroundColor =
              searchc.includes(`(No): ðŸš« ${color}`)
                ? 'lightcoral'
                : searchc.includes(color)
                  ? 'lightgreen'
                  : 'white';
          }
          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance

          // Create text node for the color
          const colorText = document.createTextNode(color);
          const textContainer = document.createElement('div');
          textContainer.style.flexGrow = '1'; // Allow text to take available space
          if (color !== '...') {
            textContainer.appendChild(colorText); // Append text to text container
          }
          else {
            textContainer.appendChild(document.createTextNode(''))
          }
          line.appendChild(textContainer);
          // Create YES button
          if (color === ' ') {

            const yesButton = document.createElement('button');
            yesButton.textContent = 'YES';
            yesButton.style.marginLeft = '5px'; // Space between text and button

            yesButton.style.backgroundColor = 'lightgreen';
            yesButton.style.color = 'black';
            yesButton.style.border = 'none';
            yesButton.style.borderRadius = '5px';
            yesButton.style.padding = '3.5px 5px';
            yesButton.style.fontFamily = "'Strait', sans-serif";
            yesButton.style.fontSize = "10px";
            // Create NO button
            const noButton = document.createElement('button');
            noButton.textContent = 'NO';
            noButton.style.marginLeft = '6px'; // Increased space between YES and NO

            noButton.style.backgroundColor = 'lightcoral';
            noButton.style.color = 'black';
            noButton.style.border = 'none';
            noButton.style.borderRadius = '5px';
            noButton.style.padding = '3.5px 5px';
            noButton.style.fontFamily = "'Strait', sans-serif";
            noButton.style.fontSize = "10px";

            // Add additional right margin to the last button
            noButton.style.marginRight = '1px'; // Space from the right margin
            line.appendChild(textContainer);
            line.appendChild(yesButton);
            line.appendChild(noButton);
          } else if (color !== ' ' && color !== 'Main Color' && color !== '...' && color !== '  ' && color !== 'GX' && color !== '5Ds' && color !== 'Zexal' && color !== 'VRAINS' && color !== 'Arc-V' && color !== 'Duel Monsters') {
            const yesButton = document.createElement('button');

            yesButton.style.cssText = `
    margin: 0 10px 0 5px; 
    cursor: pointer; 
    background-color: transparent; 
    color: black; 
    border: 2px solid lightgreen; 
    border-radius: 50%; 
    width: 16px; 
    height: 16px; 
    padding: 0; 
    font-family: 'Strait', sans-serif; 
     float: right; 
        float: right; 
           
    margin-right: 12px; 
   
`;


            if (color.includes("Optional")) {
              yesButton.style.cssText = `
    margin: 0 22px 0 5px; 
    cursor: pointer; 
    background-color: transparent; 
    color: black; 
    border: 2px solid lightgreen; 
    border-radius: 50%; 
    width: 16px; 
    height: 16px; 
    padding: 0; 
    font-family: 'Strait', sans-serif; 
     float: right; 
        float: right; 
           
    margin-right: 33px; 
   
`;

            }


            // Create NO button
            const noButton = document.createElement('button');
            noButton.style.cssText = `
    cursor: pointer; 
    background-color: transparent; 
    color: black; 
    border: 2px solid lightcoral; 
    border-radius: 50%; 
    width: 16px; 
    height: 16px; 
    padding: 0; 
    font-family: 'Strait', sans-serif; 
     float: right; 
   
    margin-right: 5px; 
`;

            // Optionally, you can add some hover effects
            yesButton.onmouseover = () => yesButton.style.backgroundColor = 'lightgreen';
            yesButton.onmouseout = () => yesButton.style.backgroundColor = 'transparent';

            noButton.onmouseover = () => noButton.style.backgroundColor = 'lightcoral';
            noButton.onmouseout = () => noButton.style.backgroundColor = 'transparent';



            // Event listener for YES button
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

            // Event listener for the yesButton
            yesButton.addEventListener('click', () => {
              line.style.transform = 'scale(0.98)';

              // Reset the transform after the animation for the pop effect
              setTimeout(() => {
                line.style.transform = 'scale(1)';
              }, 100); // Match this with the transform transition duration

              line.style.backgroundColor = 'lightgreen';

              if (!searchc.includes(color)) {
                searchc.push(color);
                // Remove the entry with (No): ðŸš« + color
                searchc = searchc.filter(item => item !== `(No): ðŸš« ${color}`); // Adjust based on your exact format
                updateNewCell(searchc);
              }
            });

            // Event listener for NO button
            noButton.addEventListener('click', () => {
              line.style.transform = 'scale(0.98)';

              // Reset the transform after the animation for the pop effect
              setTimeout(() => {
                line.style.transform = 'scale(1)';
              }, 100); // Match this with the transform transition duration
              line.style.backgroundColor = 'lightcoral';
              const index = searchc.indexOf(color);
              if (!searchc.includes("(No): ðŸš« " + color)) {
                searchc.push("(No): ðŸš« " + color);

                searchc = searchc.filter(item => item !== color); // Adjust based on your exact format

                updateNewCell(searchc);
              }
            });

            line.appendChild(yesButton);
            if (!color.includes("Optional")) {
              line.appendChild(noButton);
            }
          }

          // Append text container and buttons to line

          linesContainer.appendChild(line);
        });
        const spacer = document.createElement('div');
        spacer.style.height = '20px'; // Adjust the height as needed

        modal.appendChild(linesContainer);
        modal.appendChild(spacer);
        // Only append the lines container if the modal is empty
        //  modal.appendChild(linesContainer);
      }



      if (name.includes("Played ddBy")) {

        const characters = [
          '  ',
          'Duel Monsters',
          'ðŸŸ¦ Yugi Muto',
          'ðŸŸ© Joey Wheeler',
          'ðŸŸ© Seto Kaiba',

          'ðŸŸ« Mai Valentine',
          'ðŸŸ« Mako Tsunami',
          'ðŸŸ« Rex Raptor',
          'ðŸŸ« Weevil Underwood',
          'ðŸŸ¥ Maximillion Pegasus',
          'ðŸŸ¥ Yami Marik',
          'ðŸŸ¥ Ryo Bakura',

          '  ',
          'GX',
          'ðŸŸ¦ Jaden Yuki',
          'ðŸŸ© Chazz Princeton',
          'ðŸŸ© Zane Truesdale',
          'ðŸŸ« Alexis Rhodes',
          'ðŸŸ« Bastion Misawa',

          '  ',
          '5Ds',
          'ðŸŸ¦ Yusei Fudo',
          'ðŸŸ© Jack Atlas',
          'ðŸŸ© Crow Hogan',
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        characters.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          line.textContent = color;

          if (color !== ' ' && color !== 'Main Color' && color !== '  ' && color !== 'GX' && color !== '5Ds' && color !== 'Duel Monsters') {
            line.style.height = '30px';
            line.style.backgroundColor =
              searchc.includes(`(No): ðŸš« ${color}`)
                ? 'lightcoral'
                : searchc.includes(color)
                  ? 'lightgreen'
                  : 'white';
        
          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
        
          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          }
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }


      if (name.includes("Name")) {

       const letters = [
          'Write a specific word...',
          '',
          '... or choose Keywords',

          'ðŸ…°ï¸ One Word','ðŸ…°ï¸ðŸ…±ï¸ Two Words',  'A...', 'B...', 'C...', 'D...', 'E...', 'F...', 'G...', 'H...', 'I...', 'J...', 'K...', 'L...', 'M...', 'N...', 'O...', 'P...', 'Q...', 'R...', 'S...', 'T...', 'U...', 'V...', 'W...', 'X...', 'Y...', 'Z...'

        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        letters.forEach(color => {
        
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          line.textContent = color;



          if (color === 'Write a specific word...') {




            
            line.addEventListener('click', () => {
              line.textContent = "";

              // Create a wrapper for the input and button
              const inputWrapper = document.createElement('div');
              inputWrapper.style.display = 'flex'; // Use flexbox for alignment
              inputWrapper.style.alignItems = 'center'; // Center items vertically
              inputWrapper.style.opacity = '0'; // Start hidden
              // To fade in
              fadeIn(inputWrapper);



              const input = document.createElement('input');
              input.style.display = 'flex'; // Make the input a flex container
              input.style.alignItems = 'center'; // Center items vertically (not usually necessary for input)
              input.style.height = '30px'; // Match the line height
              input.style.fontSize = '12.5px'; // Match the font size
              input.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              input.style.border = '1px solid #ccc'; // Optional: border styling
              input.style.padding = '0 5px'; // Optional: padding for better aesthetics

              input.style.transition = 'background-color 0.9s ease, transform 0.7s ease';


              // Create a Send button
              const sendButton = document.createElement('button');
              sendButton.textContent = 'Send';
              sendButton.style.marginLeft = '5px'; // Add some spacing
              sendButton.style.height = '30px'; // Match height with line and input for alignment
              sendButton.style.fontSize = '12.5px'; // Match the font size
              sendButton.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              sendButton.style.border = '1px solid #ccc'; // Optional: border styling
              sendButton.style.backgroundColor = '#f0f0f0'; // Optional: background color
              sendButton.style.cursor = 'pointer'; // Change cursor on hover
              sendButton.style.padding = '0 10px'; // Optional: padding for better aesthetics
              sendButton.style.borderRadius = '4px'; // Optional: rounded corners
              sendButton.style.transition = 'background-color 1s'; // Optional: smooth background transition

              // Append the input and button to the wrapper
              inputWrapper.appendChild(input);
              inputWrapper.appendChild(sendButton);

              // Replace the line text with the input wrapper
              linesContainer.replaceChild(inputWrapper, line);

              // Focus on the input field
              input.focus();

              // Handle input submission when the input loses focus
              input.addEventListener('blur', () => {
                handleInputSubmission(input);
              });

              // Handle Enter key to submit the input
              input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  input.blur(); // Trigger blur event to save the text
                }
              });

              // Handle Send button click
              sendButton.addEventListener('click', () => {
                fadeOut(sendButton); // Fade out the send button
                input.blur(); // Trigger blur event to save the text

              });
              function handleInputSubmission(inputField) {
               
               // line.textContent = ''; // Clear the line text initially
               

                // Add text content to the array only if it's not already present
                if (!searchc.includes(inputField.value)) {
                  searchc.push("Name: " + inputField.value); // Add text content to the array
                  // Example usage: update the content of the newCell
                  updateNewCell(searchc);
                }

                fadeOut(sendButton); // Fade out the send button

                // Set a timeout to reintroduce the text with a transition
                setTimeout(() => {
                  linesContainer.replaceChild(line, inputWrapper); // Replace input wrapper with line
                  line.textContent = 'Write a specific word...'; // Set line text to input value
                  line.style.opacity = 0; // Start with the line hidden
                  // Trigger a reflow to restart the transition
                  line.offsetHeight; // This line forces a reflow
                  line.style.transition = 'opacity 0.5s'; // Set transition for opacity
                  line.style.opacity = 1; // Fade in the line
                }, 100); // Delay before showing the text
              }
            });

            line.style.backgroundColor = 'white';

            line.style.borderRadius = '10px'; // Rounded corners
            line.style.marginBottom = '15px'; // Space between lines
            line.style.padding = '0 10px'; // Padding inside the line for better text appearance

            line.style.cursor = 'pointer';
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';


            linesContainer.appendChild(line);
          }











          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";




          if (color !== '' && color !== '... or choose Keywords' && color !== 'Write a specific word...') {



          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }

          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
          line.textContent = color;

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          }
          linesContainer.appendChild(line);
        });
     
        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }





      if (name.includes("ATK / DEF")) {

        const letters = [
          'âš”ï¸ ATK (min): ...',
          'âš”ï¸ ATK (max): ...',
          'ðŸ›¡ï¸ DEF (min): ...',
          'ðŸ›¡ï¸ DEF (max): ...',
       
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        letters.forEach(color => {

          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          line.textContent = color;



          if (color.includes("): ...")) {





            line.addEventListener('click', () => {
              remembrance = line.textContent
              line.textContent = "";

              // Create a wrapper for the input and button
              const inputWrapper = document.createElement('div');
              inputWrapper.style.display = 'flex'; // Use flexbox for alignment
              inputWrapper.style.alignItems = 'center'; // Center items vertically
              inputWrapper.style.opacity = '0'; // Start hidden
              // To fade in
              fadeIn(inputWrapper);



              const input = document.createElement('input');
              input.style.display = 'flex'; // Make the input a flex container
              input.style.alignItems = 'center'; // Center items vertically (not usually necessary for input)
              input.style.height = '30px'; // Match the line height
              input.style.fontSize = '12.5px'; // Match the font size
              input.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              input.style.border = '1px solid #ccc'; // Optional: border styling
              input.style.padding = '0 5px'; // Optional: padding for better aesthetics

              input.style.transition = 'background-color 0.9s ease, transform 0.7s ease';


              // Create a Send button
              const sendButton = document.createElement('button');
              sendButton.textContent = 'Send';
              sendButton.style.marginLeft = '5px'; // Add some spacing
              sendButton.style.height = '30px'; // Match height with line and input for alignment
              sendButton.style.fontSize = '12.5px'; // Match the font size
              sendButton.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              sendButton.style.border = '1px solid #ccc'; // Optional: border styling
              sendButton.style.backgroundColor = '#f0f0f0'; // Optional: background color
              sendButton.style.cursor = 'pointer'; // Change cursor on hover
              sendButton.style.padding = '0 10px'; // Optional: padding for better aesthetics
              sendButton.style.borderRadius = '4px'; // Optional: rounded corners
              sendButton.style.transition = 'background-color 1s'; // Optional: smooth background transition

              // Append the input and button to the wrapper
              inputWrapper.appendChild(input);
              inputWrapper.appendChild(sendButton);

              // Replace the line text with the input wrapper
              linesContainer.replaceChild(inputWrapper, line);

              // Focus on the input field
              input.focus();

              // Handle input submission when the input loses focus
              input.addEventListener('blur', () => {
                handleInputSubmission(input);
              });

              // Handle Enter key to submit the input
              input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  input.blur(); // Trigger blur event to save the text
                }
              });

              // Handle Send button click
              sendButton.addEventListener('click', () => {
                fadeOut(sendButton); // Fade out the send button
                input.blur(); // Trigger blur event to save the text

              });

              function handleInputSubmission(inputField) {
                line.textContent = remembrance 
                line.textContent = line.textContent.replace(/(\.\.\.|[0-9]+)/g, "") + inputField.value;
                 // Set line text to input value
               
                linesContainer.replaceChild(line, inputWrapper); // Replace input wrapper with line

                // Add text content to the array only if it's not already present
                if (!searchc.includes(remembrance.replace("...", ""))) {
                  remembrance = remembrance.replace(/(\.\.\.|[0-9]+)/g, "");
                  searchc.push(remembrance.replace("...","") + inputField.value); // Add text content to the array
                  // Example usage: update the content of the newCell
                  updateNewCell(searchc);
                }
              }
            });

            line.style.backgroundColor = 'white';

            line.style.borderRadius = '10px'; // Rounded corners
            line.style.marginBottom = '15px'; // Space between lines
            line.style.padding = '0 10px'; // Padding inside the line for better text appearance

            line.style.cursor = 'pointer';
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';


            linesContainer.appendChild(line);
          }











          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";




          if (color !== '' && color !== '... or choose Keywords' && !color.includes("): ...")) {



            if (searchc.includes(color)) {
              line.style.backgroundColor = 'lightgreen';
            }
            else {
              line.style.backgroundColor = 'white';
            }

            line.style.borderRadius = '10px'; // Rounded corners
            line.style.marginBottom = '15px'; // Space between lines
            line.style.padding = '0 10px'; // Padding inside the line for better text appearance
            line.textContent = color;

            line.style.cursor = 'pointer';
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

            // Function to handle the click event
            line.addEventListener('click', () => {
              // Add the sink effect
              line.style.transform = 'scale(0.98)';

              // Reset the transform after the animation for the pop effect
              setTimeout(() => {
                line.style.transform = 'scale(1)';
              }, 100); // Match this with the transform transition duration

              if (line.style.backgroundColor === 'lightgreen') {
                line.style.backgroundColor = 'white'; // Change to the first color
                const index = searchc.indexOf(line.textContent);
                if (index > -1) {
                  searchc.splice(index, 1); // Remove the item from the Array
                }
                updateNewCell(searchc);
              } else {
                line.style.backgroundColor = 'lightgreen'; // Change to the second color

                // Add text content to the array only if it's not already present
                if (!searchc.includes(line.textContent)) {
                  searchc.push(line.textContent); // Add text content to the array
                  // Example usage: update the content of the newCell
                  updateNewCell(searchc);
                }
              }
            });
          }
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }



     


      if (name.includes("Monster Attributes")) {

        const atrbs = [
          'â˜… Lvl 5-6',
          'â˜… Lvl 4',
          'â˜… Lvl 5-6',
          'â˜… Lvl 7-8',
          'ðŸ‚ Beast',
          'ðŸ¦§ Beast-Warrior',
          'ðŸ’» Cyberse',
          'ðŸ‰ Dragon',
          'ðŸ¦• Dinosaur',
          'ðŸ§š Fairy',
          'ðŸŸ Fish',
          'ðŸŽƒ Fiend',
          'ðŸªž Illusion',
          'ðŸœ Insect',
          'ðŸ¤– Machine',
          'ðŸ”® Psychic',
          'ðŸŒ± Plant',
          'ðŸŒ‹ Pyro',
          'ðŸ¦Ž Reptile',
          'ðŸ—¿ Rock',
          'ðŸ¦‘ Sea Serpent',
          'ðŸª„ Spellcaster',
          'âš¡ Thunder',
          'ðŸ—¡ï¸ Warrior',
          'ðŸ¦â€ðŸ”¥ Winged Beast',
          'ðŸ‰ Wyrm',
          'ðŸ§Ÿ Zombie'
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        atrbs.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }

          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
          line.textContent = color;

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }

      if (name.includes("Card Type") ){

        const colors = [
          'ðŸŸ¢ Spell',
          'ðŸŸ£ Trap',
          'ðŸŸ¨ Normal Monster',
          'ðŸŸ§ Effect',
          'ðŸŸª Fusion',
          'ðŸŸ¦ Ritual',
          'â¬› Xyz',
          'â¬œ Synchro',
          'ðŸ’« Tuner',
          'ðŸ”¶ Pendulum',
          'ðŸ”· Link',
     


        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        colors.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }

          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance
          line.textContent = color;

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          linesContainer.appendChild(line);
        });







   


















        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }













      function fadeIn(element) {
        element.style.transition = 'opacity 0.9s ease';
        element.style.opacity = '0'; // Start from fully transparent
        element.style.visibility = 'visible'; // Make it visible immediately

        requestAnimationFrame(() => {
          element.style.opacity = '1'; // Start fading in
        });
      }

      function fadeOut(element) {
        element.style.transition = 'opacity 0.2s ease';
        element.style.opacity = '1'; // Start from fully opaque

        requestAnimationFrame(() => {
          element.style.opacity = '0'; // Start fading out
        });

        // Set visibility to hidden after the fade-out transition ends
        setTimeout(() => {
          element.style.visibility = 'hidden';
        }, 200); // Match this duration with your fade-out time
      }


      if (name.includes( "Effect")) {

        const teffects = [
'Write specific effect text...',
'',
          '... or choose Keywords',
          '1ï¸âƒ£ Effect: 1 Sentence',
          '2ï¸âƒ£ Effect: 2 Sentences',
          '3ï¸âƒ£ Effect: 3 Sentences',
          'ðŸŽ Add',
          'ðŸš€ Banish',
          'â›”ï¸ Cannot be Normal Summoned',
          'ðŸª™ Coin',
          'ðŸŽ® Control',
          'â˜„ï¸ Inflict damage',
          'ðŸ’¥ Destroy',
          'ðŸŽ² Dice',
          'ðŸ‘ðŸ¼ Discard',
          'âž• Draw',
          'ðŸª¦ Graveyard',
          'ðŸ–ðŸ¼ From your hand',
          'ðŸš« Negate',
          'ðŸŽŠ Special Summon',
          'ðŸŽ¯ Target',
          'â™™ Tribute'
        ];
        const linesContainer = document.createElement('div');
        linesContainer.style.display = 'flex';
        linesContainer.style.flexDirection = 'column';
        linesContainer.style.gap = '2px'; // Space between lines

        // Add 7 lines with different colors
        teffects.forEach(color => {
          const line = document.createElement('div');
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.justifyContent = 'flex-start';
          line.style.height = '30px';
          line.style.fontSize = '12.5px';
          line.style.fontFamily = "'Strait', sans-serif";
          line.textContent = color;





          if (color === 'Write specific effect text...') {
            line.addEventListener('click', () => {
              line.textContent = "";

              // Create a wrapper for the input and button
              const inputWrapper = document.createElement('div');
              inputWrapper.style.display = 'flex'; // Use flexbox for alignment
              inputWrapper.style.alignItems = 'center'; // Center items vertically
              inputWrapper.style.opacity = '0'; // Start hidden
              // To fade in
              fadeIn(inputWrapper);



              const input = document.createElement('input');
              input.style.display = 'flex'; // Make the input a flex container
              input.style.alignItems = 'center'; // Center items vertically (not usually necessary for input)
              input.style.height = '30px'; // Match the line height
              input.style.fontSize = '12.5px'; // Match the font size
              input.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              input.style.border = '1px solid #ccc'; // Optional: border styling
              input.style.padding = '0 5px'; // Optional: padding for better aesthetics

              input.style.transition = 'background-color 0.9s ease, transform 0.7s ease';


              // Create a Send button
              const sendButton = document.createElement('button');
              sendButton.textContent = 'Send';
              sendButton.style.marginLeft = '5px'; // Add some spacing
              sendButton.style.height = '30px'; // Match height with line and input for alignment
              sendButton.style.fontSize = '12.5px'; // Match the font size
              sendButton.style.fontFamily = "'Strait', sans-serif"; // Match the font family
              sendButton.style.border = '1px solid #ccc'; // Optional: border styling
              sendButton.style.backgroundColor = '#f0f0f0'; // Optional: background color
              sendButton.style.cursor = 'pointer'; // Change cursor on hover
              sendButton.style.padding = '0 10px'; // Optional: padding for better aesthetics
              sendButton.style.borderRadius = '4px'; // Optional: rounded corners
              sendButton.style.transition = 'background-color 1s'; // Optional: smooth background transition

              // Append the input and button to the wrapper
              inputWrapper.appendChild(input);
              inputWrapper.appendChild(sendButton);

              // Replace the line text with the input wrapper
              linesContainer.replaceChild(inputWrapper, line);

              // Focus on the input field
              input.focus();

              // Handle input submission when the input loses focus
              input.addEventListener('blur', () => {
                handleInputSubmission(input);
              });

              // Handle Enter key to submit the input
              input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  input.blur(); // Trigger blur event to save the text
                }
              });

              // Handle Send button click
              sendButton.addEventListener('click', () => {
                fadeOut(sendButton); // Fade out the send button
                input.blur(); // Trigger blur event to save the text
               
              });

              function handleInputSubmission(inputField) {

                // line.textContent = ''; // Clear the line text initially


                // Add text content to the array only if it's not already present
                if (!searchc.includes(inputField.value)) {
                  searchc.push("Effect: " + inputField.value); // Add text content to the array
                  // Example usage: update the content of the newCell
                  updateNewCell(searchc);
                }

                fadeOut(sendButton); // Fade out the send button

                // Set a timeout to reintroduce the text with a transition
                setTimeout(() => {
                  linesContainer.replaceChild(line, inputWrapper); // Replace input wrapper with line
                  line.textContent = 'Write specific effect text...'; // Set line text to input value
                  line.style.opacity = 0; // Start with the line hidden
                  // Trigger a reflow to restart the transition
                  line.offsetHeight; // This line forces a reflow
                  line.style.transition = 'opacity 0.5s'; // Set transition for opacity
                  line.style.opacity = 1; // Fade in the line
                }, 100); // Delay before showing the text
              }
     

            });



  line.style.backgroundColor = 'white';

            line.style.borderRadius = '10px'; // Rounded corners
            line.style.marginBottom = '15px'; // Space between lines
            line.style.padding = '0 10px'; // Padding inside the line for better text appearance

            line.style.cursor = 'pointer';
            line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

     
  linesContainer.appendChild(line);
          }
        
    
  










          if (color !== '' && color !== '... or choose Keywords' && color !== 'Write specific effect text...'){
          if (searchc.includes(color)) {
            line.style.backgroundColor = 'lightgreen';
          }
          else {
            line.style.backgroundColor = 'white';
          }


          line.style.borderRadius = '10px'; // Rounded corners
          line.style.marginBottom = '15px'; // Space between lines
          line.style.padding = '0 10px'; // Padding inside the line for better text appearance

          line.style.cursor = 'pointer';
          line.style.transition = 'background-color 0.9s ease, transform 0.2s ease';

          // Function to handle the click event
          line.addEventListener('click', () => {
            // Add the sink effect
            line.style.transform = 'scale(0.98)';

            // Reset the transform after the animation for the pop effect
            setTimeout(() => {
              line.style.transform = 'scale(1)';
            }, 100); // Match this with the transform transition duration

            if (line.style.backgroundColor === 'lightgreen') {
              line.style.backgroundColor = 'white'; // Change to the first color
              const index = searchc.indexOf(line.textContent);
              if (index > -1) {
                searchc.splice(index, 1); // Remove the item from the Array
              }
              updateNewCell(searchc);
            } else {
              line.style.backgroundColor = 'lightgreen'; // Change to the second color

              // Add text content to the array only if it's not already present
              if (!searchc.includes(line.textContent)) {
                searchc.push(line.textContent); // Add text content to the array
                // Example usage: update the content of the newCell
                updateNewCell(searchc);
              }
            }
          });
          }
          linesContainer.appendChild(line);
        });

        // Only append the lines container if the modal is empty
        modal.appendChild(linesContainer);
      }


      // Close modal when clicking outside the textbox
      modal.addEventListener('click', function (event) {
        if (event.target === modal) {
          closeModalans(); // Use closeModalans to clear the modal content
        }
      });
    }







    function indice2() {
      // Create a table element
      const table = document.createElement('table');
      table.border = '1'; // Add border to the table for visibility

      // Center the table and make it adapt to different screen sizes
      table.style.margin = '0 auto';
      table.style.width = '60%';
      table.style.borderCollapse = 'collapse';
      table.style.boxShadow = '0 4px 8px rgba(0, 0, 0, 0.1)';
      table.style.borderRadius = '10px';
      table.style.overflow = 'hidden';

      // Array of names
      const names = ['Name','Card Type', 'Monster Attributes',  'ATK / DEF', 'Effect',  'Played By'];

      // Create rows with names
      names.forEach(name => {
        // Create a new row
        const row = table.insertRow();

        // Create a new cell
        const cell = row.insertCell();

        // Add the name to the cell
        cell.textContent = name;
        cell.style.fontFamily = "'Strait', sans-serif";
        // Style the cell
        cell.style.padding = '10px';
        cell.style.border = '1px solid #ddd';
        cell.style.textAlign = 'left';
        cell.style.backgroundColor = '#f9f9f9';
        cell.style.fontSize = '14px';
        cell.style.color = '#333';
        cell.style.fontWeight = 'bold';  // Set the text to bold
        cell.style.cursor = 'pointer';

        // Add hover effect using inline style
        cell.addEventListener('mouseover', () => {
          cell.style.backgroundColor = 'rgba(139, 69, 19, 0.1)'; // Light brown background
          cell.style.color = '#3e2723'; // Darker brown text color

        });

        cell.addEventListener('mouseout', () => {
          cell.style.backgroundColor = '#f9f9f9'; // Original background color
          cell.style.color = 'black'; // Original text color


        });

        cell.addEventListener('click', () => {
          showModal(name);
        });
      });   

      // Append the table to the body or another container element
      document.body.appendChild(table);
      // Append the table to the body or another container element



    }

 


    function createNewCellContainer() {
      // Create a blank row for spacing
      let blankRow = document.createElement("div");
      blankRow.style.height = "20px"; // Adjust the height as needed



      // Append the blankRow to a parent element
      document.body.appendChild(blankRow); // Replace with the appropriate parent element
      // Create the container for the new cell
      let newCellContainer = document.createElement("div");
      newCellContainer.style.display = "table";
      newCellContainer.style.margin = "20px auto"; // Center the new cell container on the screen
      newCellContainer.style.border = "1px solid black"; // Style the new cell container
      newCellContainer.style.borderRadius = '10px'; // Rounded corners
      newCellContainer.style.backgroundColor = 'white';
      // Create the new cell
      newCell = document.createElement("div");
      newCell.textContent = "Criteria will show here"; // Add content to the new cell
      newCell.style.display = "table-cell";
      newCell.style.padding = "10px"; // Adjust padding as needed
      newCell.style.textAlign = "left"; // Align the text to the left



      // Make the cell adaptive to screen sizes
      newCell.style.width = "75vw"; // Use viewport width to make it adaptive
      newCell.style.height = "10vh"; // Use viewport height to make it adaptive
      newCell.style.maxWidth = "110%"; // Ensure the width doesn't exceed 90% of the parent container
      newCell.style.maxHeight = "50vh"; // Ensure the height doesn't exceed 50% of the viewport height
      newCell.style.overflow = "auto"; // Enable scrollbars for overflow



      newCell.style.fontSize = '12.5px';
      newCell.style.fontFamily = "'Strait', sans-serif";

      // Append the new cell to the container
      newCellContainer.appendChild(newCell);

      // Append the blank row and new cell container to the body
      document.body.appendChild(blankRow);


      var button = document.createElement('button');
      button.textContent = 'Show';
      button.id = 'clickMe2Button';
      button.style.marginRight = '10px'; // Add some space before the edge
      button.style.marginBottom = '10px'; // Add some space before the edge
      button.classList.add('coolButton2'); // Add a class for styling
      // button.style.marginLeft = '12px';

      // Style the button
      button.textContent = 'Search';


      // Position the button at the bottom left of the container
      button.style.position = 'absolute'; // Absolute positioning
      button.style.bottom = '0'; // Align to the bottom
      button.style.right = '0'; // Align to the left

      // Ensure the container has relative positioning
      newCellContainer.style.position = 'relative'; // Needed for absolute positioning inside it


      // Add event listener to the button to create and add a table
      // Add event listener to the button to create and add a table
      button.addEventListener('click', function () {


      



        let flags2 = allcards.filter(flag =>
          searchc
            .filter(item =>
              item !== "Optional: Flags with the selected colors only" &&
              !item.includes("Effect: ") &&// Exclude items containing "Effect: " 
              !item.includes("Name: ") && // Exclude items containing "Effect: "
              !item.includes("âš”ï¸ ATK (min): ") &&// Exclude items containing "Effect: "
              !item.includes("âš”ï¸ ATK (max): ") &&// Exclude items containing "Effect: "
              !item.includes("ðŸ›¡ï¸ DEF (min): ") &&// Exclude items containing "Effect: "
              !item.includes("ðŸ›¡ï¸ DEF (max): ") // Exclude items containing "Effect: "
            &&    !item.includes("(No):") // Exclude items containing "Effect: "
            )
            .every(color =>
              flag.Items.includes(conditionated(color))
            )
        );


        flagseff = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("Effect: ")) // Filter for items containing "Effect: "
            .every(color =>
              flag.efct.toLowerCase().includes(color.replace("Effect: ", "").toLowerCase())
            )
        );
      

        flagsatkmin = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("âš”ï¸ ATK (min): ")) // Filter for items containing "ATK (min): "
            .every(item => parseInt(flag.atkval, 10) >= parseInt(item.replace("âš”ï¸ ATK (min): ", ""), 10)) // Use '>' for comparison
        );

        flagsatkmax = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("âš”ï¸ ATK (max): ")) // Filter for items containing "ATK (min): "
            .every(item => parseInt(flag.atkval, 10) <= parseInt(item.replace("âš”ï¸ ATK (max): ", ""), 10)) // Use '>' for comparison
        );

        flagsdefmin = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("ðŸ›¡ï¸ DEF (min): ")) // Filter for items containing "ATK (min): "
            .every(item => parseInt(flag.defval, 10) >= parseInt(item.replace("ðŸ›¡ï¸ DEF (min): ", ""), 10)) // Use '>' for comparison
        );

        flagsdefmax = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("ðŸ›¡ï¸ DEF (max): ")) // Filter for items containing "ATK (min): "
            .every(item => parseInt(flag.defval, 10) <= parseInt(item.replace("ðŸ›¡ï¸ DEF (max): ", ""), 10)) // Use '>' for comparison
        );



        negativeflags = allcards.filter(flag =>
          searchc.filter(item => item.includes("(No):")).every(color => {
            const conditionedColor = conditionated(color.replace("(No): ðŸš« ", ""));

            return !flag.Items.includes(conditionedColor) 
          })
        );

        if (negativeflags[0] !== undefined) {
          allcards = negativeflags.filter(flag => allcards.includes(flag));
        }

        flagsname = allcards.filter(flag =>
          searchc
            .filter(item => item.includes("Name: ")) // Filter for items containing "Effect: "
            .every(color =>
              flag.couname.toLowerCase().includes(color.replace("Name: ", "").toLowerCase())
            )
        );


        flagsaux = flagseff.filter(flag =>
          flagsname.includes(flag) && flagsatkmin.includes(flag) && flagsatkmax.includes(flag) && flagsdefmin.includes(flag) && flagsdefmax.includes(flag)
        );


        let flags = flags2.filter(flag =>
          flagsaux.includes(flag)
        );
       



        const ul = document.createElement('ul');
        ul.style.listStyleType = 'none';
        ul.style.padding = '0';
        ul.style.margin = '0';


        const li2 = document.createElement('li');

        // Set the text content for the list item
        li2.textContent = flags.length + " results";

        // Check for the number of results
        if (flags.length > 249) {
          li2.textContent = "250+ results";
        }

        // Style the list item
        li2.style.display = 'flex';
        li2.style.alignItems = 'center';
        li2.style.marginBottom = '10px'; // Optional
        li2.style.fontWeight = 'bold'; // Make the text bold

        // Create the button
        const btnback7 = document.createElement('button');
        btnback7.textContent = "Order by";
        btnback7.style.cssText = "margin-left: auto; padding: 4px 8px; background: lightgray; color: black; border: none; font-size: 10px; font-family: 'Strait', sans-serif; cursor: pointer; border-radius: 4px;";



        // Append the button to li2
        li2.appendChild(btnback7);

        // Add event listener to the button to open the modal
        btnback7.addEventListener('click', () => {
          showModalExtra("Order By", flags);

        });
        // Append li2 to the unordered list
        ul.appendChild(li2);

        

        flags.slice(0, 250).forEach(flag => {
          const li = document.createElement('li');
          li.style.display = 'flex';
          li.style.alignItems = 'center';
          li.style.marginBottom = '10px'; // Optional: add some space between list items

          // Create an anchor element for the hyperlink
          const a = document.createElement('a');
          a.href = flag.cardlink;  // Set the URL from flags.cardlink
          a.style.textDecoration = 'none';  // Remove underline from text (optional)
          a.style.color = 'inherit';  // Keep the original text color
          a.style.display = 'flex';  // Make anchor a flex container
          a.style.alignItems = 'center';  // Center items vertically in the anchor

          // Create an image element for the flag
          const img = document.createElement('img');
          img.src = flag.cardpic;
          img.alt = `${flag.couname} Flag`;
          img.style.width = '20px'; // Adjust the width as needed
          img.style.height = 'auto'; // Adjust the height as needed
          img.style.marginRight = '10px'; // Space between the image and text
          img.style.borderRadius = '10%'; // Rounded corners
          img.style.border = '1px solid #000'; // Add a border (adjust color and thickness as needed)

          // Set image to be clickable and trigger modal
          img.style.cursor = "pointer";
          img.addEventListener('click', function (e) {
            
            e.preventDefault();  // Prevent the link from being followed when clicking the image
            showmodalCard(flag);
          });

          // Append the image to the anchor
          a.appendChild(img);

          // Set the text content of the anchor
          const textNode = document.createTextNode(flag.couname );
          const atkSpan = document.createElement('span');
          atkSpan.style.marginLeft = 'auto'; // Push ATK text to the right
          atkSpan.textContent = "(â˜†" +`${flag.lvel}` + ") " + `${flag.atkval}` + " - " +`${flag.defval}`;
          atkSpan.style.fontSize = '0.7em'; // Set smaller font size
          a.appendChild(textNode);
          li.appendChild(a);


          if (flag.atkval!== undefined && flag.defval !== undefined){
          li.appendChild(atkSpan); // Append the ATK text after the anchor
          // Append the list item to the unordered list
          }
          ul.appendChild(li);
        });

        newCell2.textContent = "";
        newCell2.appendChild(ul);
      });


      // Append the button to the container
      newCellContainer.appendChild(button);


      document.body.appendChild(newCellContainer);
    }



    // Function to update the content of the newCell with a list of searchc entries
    function updateNewCell(searchc) {
      if (newCell2) {
        newCell2.innerHTML = ''; // Option 1: Set innerHTML to empty string

        // Option 2: Remove all child nodes
        while (newCell2.firstChild) {
          newCell2.removeChild(newCell2.firstChild);
        }
      }

      searchc.sort();
      if (newCell) {
        newCell.innerHTML = ""; // Clear the existing content
        let list = document.createElement("ul"); // Create a new list element
        list.style.listStyleType = "none"; // Remove default list styling
        list.style.padding = "0"; // Remove default padding
        list.style.textAlign = "left"; // Align the list items to the left

        searchc.forEach((item, index) => {
          let listItem = document.createElement("li"); // Create a new list item for each entry


          listItem.textContent = item; // Set the text content of the list item

          if (!item.includes("(No):")) {
            listItem.textContent = "âœ… " + "\u00A0" + "\u00A0" + "\u00A0" + "\u00A0" + item; // Use quotes for the non-breaking space
          }
          else {
            listItem.textContent = "â›”ï¸ " + "\u00A0" + "\u00A0" + "\u00A0" + "\u00A0" + item.replace("(No): ðŸš«", ""); // Use quotes for the non-breaking space
          }

          listItem.style.margin = "5px 0"; // Add margin between list items

          // Create a small "X" to remove the item
          let removeButton = document.createElement("span");
          removeButton.textContent = "Ã—"; // Text for the "X"
          removeButton.style.color = "black"; // Change the color of the "X"
          removeButton.style.cursor = "pointer"; // Change cursor to pointer
          removeButton.style.marginLeft = "15px"; // Space between item text and "X"
          removeButton.style.fontWeight = "bold"; // Make the "X" bold
          removeButton.style.fontSize = "14px"; // Increase the font size
          removeButton.style.transition = "color 0.3s"; // Smooth color transition on hover
          removeButton.style.transform = "translateY(-1px)"; // Lower the "X" a tiny bit



          // Add hover effect
          removeButton.onmouseover = function () {
            removeButton.style.color = "gray"; // Change color on hover
          };

          removeButton.onmouseout = function () {
            removeButton.style.color = "black"; // Revert color when not hovering
          };

          // Add click event to remove the list item
          removeButton.onclick = function () {
            searchc.splice(index, 1); // Remove the item from searchc
            updateNewCell(searchc); // Update the displayed list
          };

          listItem.appendChild(removeButton); // Append the "X" to the list item
          list.appendChild(listItem); // Append the list item to the list

          if (listItem.textContent.includes("â›”ï¸")) {
            listItem.style.color = "red"; // Change text color to red
          }
          else {
            listItem.style.color = "green"; // Change text color to red
          }


        });

        newCell.appendChild(list); // Append the list to the newCell
      } else {
        console.warn("newCell does not exist. Please create it first.");
      }
    }




    function createNewCellContainer2() {
      // Create a blank row for spacing

      // Create the container for the new cell
      let newCellContainer2 = document.createElement("div");
      newCellContainer2.style.display = "table";
      newCellContainer2.style.margin = "20px auto"; // Center the new cell container on the screen
      newCellContainer2.style.border = "1px solid black"; // Style the new cell container
      newCellContainer2.style.borderRadius = '10px'; // Rounded corners
      newCellContainer2.style.backgroundColor = 'white';
      // Create the new cell
      newCell2 = document.createElement("div");
      newCell2.textContent = "Results"; // Add content to the new cell
      newCell2.style.display = "table-cell";
      newCell2.style.padding = "10px"; // Adjust padding as needed
      newCell2.style.textAlign = "left"; // Align the text to the left



      // Make the cell adaptive to screen sizes
      newCell2.style.width = "75vw"; // Use viewport width to make it adaptive
      newCell2.style.height = "10vh"; // Use viewport height to make it adaptive
      newCell2.style.maxWidth = "110%"; // Ensure the width doesn't exceed 90% of the parent container
      newCell2.style.maxHeight = "50vh"; // Ensure the height doesn't exceed 50% of the viewport height
      newCell2.style.overflow = "auto"; // Enable scrollbars for overflow



      newCell2.style.fontSize = '12.5px';
      newCell2.style.fontFamily = "'Strait', sans-serif";

      // Append the new cell to the container
      newCellContainer2.appendChild(newCell2);





      document.body.appendChild(newCellContainer2);
    }



  function conditionated(critt) {
        if (critt.includes("(No):")) {critt = critt.replace("(No): ðŸš«", "");}
        const lookupMap = {
          // Characters
          'Yugi Muto': "anYugi",
          'Joey Wheeler [Katsuya Jonouchi]': "anYugi",
          'Seto Kaiba': "anSeto",
          'Maximillion Pegasus [Pegasus J. Crawford]': "anPega",
          'Yami Marik': "anMari",
          'Bakura': "anBaku",
          'Mai Valentine': "anMaiV",
          'Weevil Underwood': "anWeev",
          'Rex Raptor': "anRexR",

          'Jaden Yuki': "anJadn",
          'Alexis Rhodes': "anAlxs",
          'Chazz Princeton': "anChaz",
          'Zane Truesdale': "anZane",
          'Bastion Misawa': "anBast",
          'Nightshroud': "anNigh",
          'Jim Cook': "anCook",
          'Yubel': "anYubl",
          'Sartorius': "anSart",

          'Yusei Fudo': "anYuse",
          'Jack Atlas': "anJack",
          'Crow Hogan': "anCrbw",
          'Akiza Izinski': "anAkii",
          'Kalin Kessler': "anKali",
          'Yuma Tsukumo': "anYuma",

          'Yuya Sasaki': "anYuya",
          'Sylvio Sawatari': "anSylv",
          'Declan Akaba [Akaba Reiji]': "anDecl",

          'Playmaker': "anPlmk",
          'Blue Angel': "anBlue",
          'George Gore': "anGeor",
          'Soulburner': "anSoul",
          'Varis': "anVari",
          'Ai': "anAIIA",


          'anDeclan': "anDecl",


          // Card types
          'ðŸŸ¢ Spell': "spells",
          'ðŸŸ£ Trap': "traps",
          'ðŸŸ¨ Normal Monster': "msNorm",
          'ðŸŸ§ Effect': "msEfct",
          'ðŸŸª Fusion': "msFuse",
          'ðŸŸ¦ Ritual': "msRitu",
          'â¬› Xyz': "msXYZs",
          'â¬œ Synchro': "msSync",
          'ðŸ’« Tuner': "msTune",
          'ðŸ”¶ Pendulum': "msPend",
          'ðŸ”· Link': "msLink",

          // Levels
          'â˜… Lvl 5-6': "lvl056",

          // Word counts
          'ðŸ…°ï¸ One Word': "words1",
          'ðŸ…°ï¸ðŸ…±ï¸ Two Words': "words2",

          // Starting letters
          'A...': "startA", 'B...': "startB", 'C...': "startC", 'D...': "startD",
          'E...': "startE", 'F...': "startF", 'G...': "startG", 'H...': "startH",
          'I...': "startI", 'J...': "startJ", 'K...': "startK", 'L...': "startL",
          'M...': "startM", 'N...': "startN", 'O...': "startO", 'P...': "startP",
          'Q...': "startQ", 'R...': "startR", 'S...': "startS", 'T...': "startT",
          'U...': "startU", 'V...': "startV", 'W...': "startW", 'X...': "startX",
          'Y...': "startY", 'Z...': "startZ",

          // Attack values
          'âš”ï¸ ATK: 100-500': "AT0500",
          'âš”ï¸ ATK: 600-1000': "AT1000",
          'âš”ï¸ ATK: 1100-1500': "AT1500",
          'âš”ï¸ ATK: 1500-2000': "AT2000",
          'âš”ï¸ ATK: 2000-2500': "AT2500",
          'âš”ï¸ ATK: 2500-3000': "AT3000",
          'âš”ï¸ ATK: 2050-3000': "ATK200",
          'âš”ï¸ ATK: 1050-2000': "ATK100",
          'âš”ï¸ ATK: 50-1000': "ATK000",

          // Defense values
          'ðŸ›¡ï¸ DEF: 100-500': "DF0500",
          'ðŸ›¡ï¸ DEF: 600-1000': "DF1000",
          'ðŸ›¡ï¸ DEF: 1100-1500': "DF1500",
          'ðŸ›¡ï¸ DEF: 1500-2000': "DF2000",
          'ðŸ›¡ï¸ DEF: 2000-2500': "DF2500",
          'ðŸ›¡ï¸ DEF: 2500-3000': "DF3000",

          // Types
          'ðŸ‚ Beast': "tpBeas",
          'ðŸ¦§ Beast-Warrior': "tpBewa",
          'ðŸ’» Cyberse': "tpCybe",
          'ðŸ‰ Dragon': "tpDrag",
          'ðŸ¦• Dinosaur': "tpDino",
          'ðŸ§š Fairy': "tpFair",
          'ðŸŸ Fish': "tpFish",
          'ðŸŽƒ Fiend': "tpFien",
          'ðŸªž Illusion': "tpIllu",
          'ðŸœ Insect': "tpInse",
          'ðŸ¤– Machine': "tpMach",
          'ðŸ”® Psychic': "tpPsyc",
          'ðŸŒ± Plant': "tpPlan",
          'ðŸŒ‹ Pyro': "tpPyro",
          'ðŸ¦Ž Reptile': "tpRept",
          'ðŸ—¿ Rock': "tpRock",
          'ðŸ¦‘ Sea Serpent': "tpSeap",
          'ðŸª„ Spellcaster': "tpSpel",
          'âš¡ Thunder': "tpThun",
          'ðŸ—¡ï¸ Warrior': "tpWarr",
          'ðŸ¦â€ðŸ”¥ Winged Beast': "tpWing",
          'ðŸ‰ Wyrm': "tpWyrm",
          'ðŸ§Ÿ Zombie': "tpZomb",

          // Effects
          '1ï¸âƒ£ Effect: 1 Sentence': "sntnc1",
          '2ï¸âƒ£ Effect: 2 Sentences': "sntnc2",
          '3ï¸âƒ£ Effect: 3 Sentences': "sntnc3",
          'ðŸŽ Add': "efAdds",
          'ðŸš€ Banish': "efBani",
          'â›”ï¸ Cannot be Normal Summoned': "efCant",
          'ðŸª™ Coin': "efCoin",
          'ðŸŽ® Control': "efCtrl",
          'â˜„ï¸ Inflict damage': "efDamg",
          'ðŸ’¥ Destroy': "efDest",
          'ðŸŽ² Dice': "efDice",
          'ðŸ‘ðŸ¼ Discard': "efDisc",
          'âž• Draw': "efDraw",
          'ðŸª¦ Graveyard': "efGrav",
          'ðŸ–ðŸ¼ From your hand': "efHand",
          'ðŸš« Negate': "efNega",
          'ðŸŽŠ Special Summon': "efSpec",
          'ðŸŽ¯ Target': "efTarg",
          'â™™ Tribute': "efTrib",

          // Attributes
          'ðŸŒ• LIGHT': "atLIGH",
          'ðŸŒ‘ DARK': "atDARK",
          'ðŸ’¨ WIND': "atWIND",
          'ðŸªµ EARTH': "atEART",
          'ðŸ”¥ FIRE': "atFIRE",
          'ðŸ’§ WATER': "atWATE",
          'â˜¯ï¸ DIVINE': "atDIVI"
    };
      for (const [key, value] of Object.entries(lookupMap)) {if (critt.includes(key)) {return value;}}
      return null;
    }



    function backdropping(commando) {
      if (commando === "open") {
        let backdrop = document.getElementById('modal-backdrop');
        if (!backdrop) {
          backdrop = document.createElement('div');
          Object.assign(backdrop.style, {
            position: 'fixed',
            top: '0',
            left: '0',
            width: '100vw',
            height: '100vh',
            backgroundColor: 'rgba(0, 0, 0, 0.8)',
            zIndex: '1',  // Backdrop z-index
            opacity: '0',
            transition: 'opacity 0.65s',
            overflow: 'hidden'
          });
          backdrop.id = 'modal-backdrop';
          document.body.appendChild(backdrop);

          const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
          document.body.style.paddingRight = `${scrollbarWidth}px`;
          document.body.style.overflow = 'hidden';

          requestAnimationFrame(() => {
            backdrop.style.opacity = '1';
          });
        }
      }

      if (commando === "close") {
        let backdrop = document.getElementById('modal-backdrop');
        if (backdrop) {
          backdrop.style.opacity = '0'; // Fade out
          backdrop.remove();
          document.body.style.paddingRight = '';
          document.body.style.overflow = ''; // Restore body scrolling
        }
      }
    }


    //showmodalCard is the modal that appears with all the info of a card
    function showmodalCard(cardmax) {

      nameofcard = cardmax.couname
      imgofcard = cardmax.cardpic
  
      const modal = document.getElementById('modalq');
      const headline = document.getElementById('modal-headlineq');
      const btnmodal = document.getElementById('close-modalq');

      function closeModalans() {
        setTimeout(() => {
          modal.style.display = "none";
          if (modal.contains(img)) {modal.removeChild(img);}
          if (modal.contains(ul)) {modal.removeChild(ul);}
          backdropping("close")
          modal.style.display = "none";
        }, 100);
      }


      btnmodal.addEventListener("click", closeModalans);
      btnmodal.style.marginTop = '-10px'; // Adjust the value as needed to raise the button

      headline.innerHTML = nameofcard;
      headline.style.fontFamily = "'Strait', sans-serif";
      headline.style.fontSize = '15px';
      headline.style.marginTop = '10px'; // Adjust the value as needed


      const img = document.createElement('img');
      img.src = imgofcard;
      img.alt = `${nameofcard} Flag`;
      img.style.maxWidth = '100%'; // Set maximum width to 100% of modal width
      img.style.height = 'auto'; // Maintain aspect ratio
      img.height = 49*1.05;
      img.width = 67.5*1.05;
      img.style.display = 'block'; // Ensures it behaves like a block-level element
      img.style.borderRadius = '7px'; // Add rounded corners, adjust the radius as needed
      img.style.border = '2px solid black'; // Add a 1px solid black border
      img.style.cursor = "pointer";

      img.addEventListener('click', function () {
        window.open(imgofcard, '_blank');
      });
      modal.appendChild(img);

      const ul = document.createElement('ul');
      ul.style.listStyleType = 'none';
      ul.style.padding = '0'; 



      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      //Level + ATK + DEF

      if (!cardmax.Items.includes("spells") && !cardmax.Items.includes("traps")) {
      const level_0 = document.createElement('li');
        level_0.style.height = '8px';  

        const level_1 = document.createElement('li');
        level_1.innerHTML = '<strong>Level: â˜… </strong> ';
        level_1.style.fontFamily = "'Strait', sans-serif";
        level_1.style.fontSize = '12px';
        level_1.innerHTML = level_1.innerHTML + cardmax.lvel 

        ul.appendChild(level_0);
        ul.appendChild(level_1);

        const atkdef_0 = document.createElement('li');
        atkdef_0.style.height = '8px';  // Adjust the height as needed
        ul.appendChild(atkdef_0);

        const atkdef_1 = document.createElement('li');
        atkdef_1.innerHTML = '<strong>ATK: â˜… </strong> ';
        atkdef_1.style.fontFamily = "'Strait', sans-serif";
        atkdef_1.style.fontSize = '12px';
        atkdef_1.innerHTML = '<strong>ATK: </strong> ' + cardmax.atkval + '&nbsp;<strong>DEF: </strong> ' + cardmax.defval;

        ul.appendChild(atkdef_0);
        ul.appendChild(atkdef_1);
      }



      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      //Card Type

      const lblank = document.createElement('li');
      lblank.style.height = '8px';  // Adjust the height as needed
      ul.appendChild(lblank);
      const litems = document.createElement('li');
      litems.innerHTML = '<strong>Card Type:</strong> ';
      litems.style.fontFamily = "'Strait', sans-serif";
      litems.style.fontSize = '12px';
      var shapemax = [];
      const itemMappings = {
        "spells": "ðŸŸ¢ Spell",
        "traps": "ðŸŸ£ Trap",
        "contns": "â™¾ï¸ Continuous",
        "msPend": "ðŸ”¶ Pendulum Monster",
        "msLink": "ðŸ”· Link Monster",
        "msRitu": "ðŸŸ¦ Ritual Monster",
        "msSync": "â¬œ Synchro Monster",
        "msXYZs": "â¬› Xyz Monster",
        "msFuse": "ðŸŸª Fusion Monster",
        "msEfct": "ðŸŸ§ Effect Monster",
        "msNorm": "ðŸŸ¨ Normal Monster",
        "msTune": "ðŸ’« Tuner",
        "msFlip": "â†ªï¸ Flip"
        };
      for (const [key, value] of Object.entries(itemMappings)) {if (cardmax.Items.includes(key)) {shapemax.push(value);}}
      litems.innerHTML = litems.innerHTML + shapemax.join(', ')
      ul.appendChild(litems);



      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      //Monster Attributes

      if (!cardmax.Items.includes("spells") && !cardmax.Items.includes("traps")) {
        const attribute_0 = document.createElement('li');
        attribute_0.style.height = '8px';  // Adjust the height as needed

        const attribute_1 = document.createElement('li');
        attribute_1.innerHTML = '<strong>Monster Attributes:</strong>';
        Object.assign(attribute_1.style, {
          fontFamily: "'Strait', sans-serif",
          fontSize: '12px'
        });

        const itemMap = {
          "atLIGH": "ðŸŒ• LIGHT",
          "atDARK": "ðŸŒ‘ DARK",
          "atWIND": "ðŸ’¨ WIND",
          "atEART": "ðŸªµ EARTH",
          "atFIRE": "ðŸ”¥ FIRE",
          "atWATE": "ðŸ’§ WATER",
          "atDIVI": "â˜¯ï¸ DIVINE",
          "tpAqua": "ðŸŒŠ Aqua",
          "tpBeas": "ðŸ‚ Beast",
          "tpBewa": "ðŸ¦§ Beast-Warrior",
          "tpCybe": "ðŸ’» Cyberse",
          "tpDrag": "ðŸ‰ Dragon",
          "tpDino": "ðŸ¦• Dinosaur",
          "tpFair": "ðŸ§š Fairy",
          "tpFish": "ðŸŸ Fish",
          "tpFien": "ðŸŽƒ Fiend",
          "tpIllu": "ðŸªž Illusion",
          "tpInse": "ðŸœ Insect",
          "tpMach": "ðŸ¤– Machine",
          "tpPsyc": "ðŸ”® Psychic",
          "tpPlan": "ðŸŒ± Plant",
          "tpPyro": "ðŸŒ‹ Pyro",
          "tpRept": "ðŸ¦Ž Reptile",
          "tpRock": "ðŸ—¿ Rock",
          "tpSeap": "ðŸ¦‘ Sea Serpent",
          "tpSpel": "ðŸª„ Spellcaster",
          "tpThun": "âš¡ Thunder",
          "tpWarr": "ðŸ—¡ï¸ Warrior",
          "tpWing": "ðŸ¦â€ðŸ”¥ Winged Beast",
          "tpWyrm": "ðŸ‰ Wyrm",
          "tpZomb": "ðŸ§Ÿ Zombie"
        };
        const itemmax = Object.keys(itemMap).filter(key => cardmax.Items.includes(key)).map(key => itemMap[key]);
        attribute_1.innerHTML += itemmax.join(', ');

        ul.appendChild(attribute_0);
        ul.appendChild(attribute_1);
      }
      



      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      // Anime Decks
      
      const animeMapping = {
        "anYugi": "Yugi",
        "anJoey": "Joey",
        "anSeto": "Kaiba",
        "anZane": "Zane",
        "anPega": 'Pegasus',
        "anMari": 'Marik',
        "anBaku": 'Bakura',
        "anMaiV": 'Mai',
        "anWeev": 'Weevil',
        "anRexR": 'Rex',

        "anJadn": 'Jaden',
        "anAlxs": 'Alexis',
        "anChaz": 'Chazz',
        "anZane": 'Zane',
        "anBast": 'Bastion',
        "anNigh": 'Nightshroud',
        "anCook": 'Jim',
        "anYubl": 'Yubel',
        "anSart": 'Sartorius',

        "anYuse": 'Yusei',
        "anJack": 'Jack',
        "anCrbw": 'Crow',
        "anAkii": 'Akiza',
        "anKali": 'Kalin',

        "anYuma": 'Yuma',

        "anYuya": 'Yuya',
        "anSylv": 'Sylvio',

        "anPlmk": 'Playmaker',
        "anBlue": 'Blue Angel',
        "anGeor": 'George Gore',
        "anSoul": 'Soulburner',
      };

      const animax = Object.keys(animeMapping).filter(key => cardmax.Items.includes(key)).map(key => animeMapping[key]);

      if (animax.length > 0) {
        const anim_0 = document.createElement('li');
        anim_0.style.height = '8px';  // Adjust the height as needed

        const anim_1 = document.createElement('li');
        anim_1.innerHTML = `<strong>Played by:</strong> ${animax.join(', ')}`;
        anim_1.style.fontFamily = "'Strait', sans-serif";
        anim_1.style.fontSize = '12px';

        ul.appendChild(anim_0);
        ul.appendChild(anim_1);
      }

      //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
      //Description
        const description_0 = document.createElement('li');
        description_0.style.height = '8px';  // Adjust the height as needed

        const description_1 = document.createElement('li');
        description_1.style.fontFamily = "'Strait', sans-serif";
        description_1.style.fontSize = '12px';
        description_1.innerHTML = `<strong>Effect:</strong> ${cardmax.efct || '-'}`;

        ul.appendChild(description_0);
        ul.appendChild(description_1);
      
    //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


      backdropping("open")

      modal.appendChild(ul);
      modal.style.display = 'block';
      Object.assign(modal.style, {
                    position: 'fixed',
                    zIndex: '1001',
                    background: 'white',
                    boxShadow: '0 4px 8px rgba(0, 0, 0, 0.2)',
                    width: '70%',
                    height: '60%',
                    top: '50%',
                    left: '50%',
                    transform: 'translate(-50%, -50%)',
                    overflowY: 'scroll',
                    opacity: '0',
                    transition: 'opacity 1s'
      });
      modal.offsetHeight;


      setTimeout(() => {
        modal.style.opacity = '1';
      }, 10); 
    

      const style = document.createElement('style');
            style.innerHTML = `
        #modalq::-webkit-scrollbar {
            width: 8px; /* Width of the scrollbar */
        }
        #modalq::-webkit-scrollbar-thumb {
            background: #888; /* Color of the scrollbar */
            border-radius: 10px; /* Rounded corners */
        }
        #modalq::-webkit-scrollbar-thumb:hover {
            background: #555; /* Darker color on hover */
        }
        #modalq::-webkit-scrollbar-track {
            background: #f1f1f1; /* Color of the scrollbar track */
            border-radius: 10px; /* Rounded corners */
        }
      `;
      document.head.appendChild(style);
      modal.style.maxWidth = '450px'; // Width of the modal
      modal.style.maxHeight = '800px'; // Width of the modal
      document.body.appendChild(modal);

      modal.offsetHeight;
      modal.style.opacity = '1';
    }

  //------------------------------------------------------------------------------------------------------------------------------------------------------------------------------



    createNewCellContainer();
    createNewCellContainer2();
  });
